<?php
/**
 * RmcApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * FileCloud_User_API
 *
 * FileCloud HTTP API
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * RmcApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class RmcApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation ackrmccommands
     *
     * RMC_Related_API - ackrmccommands is used to acknowledge the received rmc command
     *
     * @param  string $command_rids Command Id number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function ackrmccommands($command_rids)
    {
        list($response) = $this->ackrmccommandsWithHttpInfo($command_rids);
        return $response;
    }

    /**
     * Operation ackrmccommandsWithHttpInfo
     *
     * RMC_Related_API - ackrmccommands is used to acknowledge the received rmc command
     *
     * @param  string $command_rids Command Id number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function ackrmccommandsWithHttpInfo($command_rids)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->ackrmccommandsRequest($command_rids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ackrmccommandsAsync
     *
     * RMC_Related_API - ackrmccommands is used to acknowledge the received rmc command
     *
     * @param  string $command_rids Command Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ackrmccommandsAsync($command_rids)
    {
        return $this->ackrmccommandsAsyncWithHttpInfo($command_rids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ackrmccommandsAsyncWithHttpInfo
     *
     * RMC_Related_API - ackrmccommands is used to acknowledge the received rmc command
     *
     * @param  string $command_rids Command Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ackrmccommandsAsyncWithHttpInfo($command_rids)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->ackrmccommandsRequest($command_rids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ackrmccommands'
     *
     * @param  string $command_rids Command Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ackrmccommandsRequest($command_rids)
    {
        // verify the required parameter 'command_rids' is set
        if ($command_rids === null || (is_array($command_rids) && count($command_rids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $command_rids when calling ackrmccommands'
            );
        }

        $resourcePath = '/core/ackrmccommands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($command_rids !== null) {
            $queryParams['command_rids'] = ObjectSerializer::toQueryValue($command_rids);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation approvedeviceaccess
     *
     * RMC_Related_API - approvedeviceaccess is used to approve the status of a device from pending so that user can access FC system
     *
     * @param  string $remote_client_id Command Id number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function approvedeviceaccess($remote_client_id)
    {
        list($response) = $this->approvedeviceaccessWithHttpInfo($remote_client_id);
        return $response;
    }

    /**
     * Operation approvedeviceaccessWithHttpInfo
     *
     * RMC_Related_API - approvedeviceaccess is used to approve the status of a device from pending so that user can access FC system
     *
     * @param  string $remote_client_id Command Id number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function approvedeviceaccessWithHttpInfo($remote_client_id)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->approvedeviceaccessRequest($remote_client_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation approvedeviceaccessAsync
     *
     * RMC_Related_API - approvedeviceaccess is used to approve the status of a device from pending so that user can access FC system
     *
     * @param  string $remote_client_id Command Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approvedeviceaccessAsync($remote_client_id)
    {
        return $this->approvedeviceaccessAsyncWithHttpInfo($remote_client_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation approvedeviceaccessAsyncWithHttpInfo
     *
     * RMC_Related_API - approvedeviceaccess is used to approve the status of a device from pending so that user can access FC system
     *
     * @param  string $remote_client_id Command Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approvedeviceaccessAsyncWithHttpInfo($remote_client_id)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->approvedeviceaccessRequest($remote_client_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'approvedeviceaccess'
     *
     * @param  string $remote_client_id Command Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function approvedeviceaccessRequest($remote_client_id)
    {
        // verify the required parameter 'remote_client_id' is set
        if ($remote_client_id === null || (is_array($remote_client_id) && count($remote_client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_id when calling approvedeviceaccess'
            );
        }

        $resourcePath = '/core/approvedeviceaccess';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($remote_client_id !== null) {
            $queryParams['remote_client_id'] = ObjectSerializer::toQueryValue($remote_client_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletedevice
     *
     * RMC_Related_API - deletedevice is used to delete the device which is connected to the user's profile
     *
     * @param  string $remote_client_id Remote Client ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function deletedevice($remote_client_id)
    {
        list($response) = $this->deletedeviceWithHttpInfo($remote_client_id);
        return $response;
    }

    /**
     * Operation deletedeviceWithHttpInfo
     *
     * RMC_Related_API - deletedevice is used to delete the device which is connected to the user's profile
     *
     * @param  string $remote_client_id Remote Client ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletedeviceWithHttpInfo($remote_client_id)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->deletedeviceRequest($remote_client_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletedeviceAsync
     *
     * RMC_Related_API - deletedevice is used to delete the device which is connected to the user's profile
     *
     * @param  string $remote_client_id Remote Client ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletedeviceAsync($remote_client_id)
    {
        return $this->deletedeviceAsyncWithHttpInfo($remote_client_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletedeviceAsyncWithHttpInfo
     *
     * RMC_Related_API - deletedevice is used to delete the device which is connected to the user's profile
     *
     * @param  string $remote_client_id Remote Client ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletedeviceAsyncWithHttpInfo($remote_client_id)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->deletedeviceRequest($remote_client_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletedevice'
     *
     * @param  string $remote_client_id Remote Client ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletedeviceRequest($remote_client_id)
    {
        // verify the required parameter 'remote_client_id' is set
        if ($remote_client_id === null || (is_array($remote_client_id) && count($remote_client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_id when calling deletedevice'
            );
        }

        $resourcePath = '/core/deletedevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($remote_client_id !== null) {
            $queryParams['remote_client_id'] = ObjectSerializer::toQueryValue($remote_client_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getrmcclients
     *
     * RMC_Related_API - getrmcclients is used to get all details about the rmc clients connected to system
     *
     * @param  string $userid Username (required)
     * @param  string $start Start index of records to retrieve, Note- Index starts from 0. Default 0 (required)
     * @param  string $end Set to any number of record you want to view at once. Default 10 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RmcClients
     */
    public function getrmcclients($userid, $start, $end)
    {
        list($response) = $this->getrmcclientsWithHttpInfo($userid, $start, $end);
        return $response;
    }

    /**
     * Operation getrmcclientsWithHttpInfo
     *
     * RMC_Related_API - getrmcclients is used to get all details about the rmc clients connected to system
     *
     * @param  string $userid Username (required)
     * @param  string $start Start index of records to retrieve, Note- Index starts from 0. Default 0 (required)
     * @param  string $end Set to any number of record you want to view at once. Default 10 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RmcClients, HTTP status code, HTTP response headers (array of strings)
     */
    public function getrmcclientsWithHttpInfo($userid, $start, $end)
    {
        $returnType = '\Swagger\Client\Model\RmcClients';
        $request = $this->getrmcclientsRequest($userid, $start, $end);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RmcClients',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getrmcclientsAsync
     *
     * RMC_Related_API - getrmcclients is used to get all details about the rmc clients connected to system
     *
     * @param  string $userid Username (required)
     * @param  string $start Start index of records to retrieve, Note- Index starts from 0. Default 0 (required)
     * @param  string $end Set to any number of record you want to view at once. Default 10 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getrmcclientsAsync($userid, $start, $end)
    {
        return $this->getrmcclientsAsyncWithHttpInfo($userid, $start, $end)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getrmcclientsAsyncWithHttpInfo
     *
     * RMC_Related_API - getrmcclients is used to get all details about the rmc clients connected to system
     *
     * @param  string $userid Username (required)
     * @param  string $start Start index of records to retrieve, Note- Index starts from 0. Default 0 (required)
     * @param  string $end Set to any number of record you want to view at once. Default 10 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getrmcclientsAsyncWithHttpInfo($userid, $start, $end)
    {
        $returnType = '\Swagger\Client\Model\RmcClients';
        $request = $this->getrmcclientsRequest($userid, $start, $end);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getrmcclients'
     *
     * @param  string $userid Username (required)
     * @param  string $start Start index of records to retrieve, Note- Index starts from 0. Default 0 (required)
     * @param  string $end Set to any number of record you want to view at once. Default 10 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getrmcclientsRequest($userid, $start, $end)
    {
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling getrmcclients'
            );
        }
        // verify the required parameter 'start' is set
        if ($start === null || (is_array($start) && count($start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start when calling getrmcclients'
            );
        }
        // verify the required parameter 'end' is set
        if ($end === null || (is_array($end) && count($end) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end when calling getrmcclients'
            );
        }

        $resourcePath = '/core/getrmcclients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($userid !== null) {
            $queryParams['userid'] = ObjectSerializer::toQueryValue($userid);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getrmccommands
     *
     * RMC_Related_API - getrmccommands is used to get the generated rmc commands
     *
     * @param  string $userid User email id (required)
     * @param  string $remote_client_id Remote Client Id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RmcCommands
     */
    public function getrmccommands($userid, $remote_client_id)
    {
        list($response) = $this->getrmccommandsWithHttpInfo($userid, $remote_client_id);
        return $response;
    }

    /**
     * Operation getrmccommandsWithHttpInfo
     *
     * RMC_Related_API - getrmccommands is used to get the generated rmc commands
     *
     * @param  string $userid User email id (required)
     * @param  string $remote_client_id Remote Client Id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RmcCommands, HTTP status code, HTTP response headers (array of strings)
     */
    public function getrmccommandsWithHttpInfo($userid, $remote_client_id)
    {
        $returnType = '\Swagger\Client\Model\RmcCommands';
        $request = $this->getrmccommandsRequest($userid, $remote_client_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RmcCommands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getrmccommandsAsync
     *
     * RMC_Related_API - getrmccommands is used to get the generated rmc commands
     *
     * @param  string $userid User email id (required)
     * @param  string $remote_client_id Remote Client Id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getrmccommandsAsync($userid, $remote_client_id)
    {
        return $this->getrmccommandsAsyncWithHttpInfo($userid, $remote_client_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getrmccommandsAsyncWithHttpInfo
     *
     * RMC_Related_API - getrmccommands is used to get the generated rmc commands
     *
     * @param  string $userid User email id (required)
     * @param  string $remote_client_id Remote Client Id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getrmccommandsAsyncWithHttpInfo($userid, $remote_client_id)
    {
        $returnType = '\Swagger\Client\Model\RmcCommands';
        $request = $this->getrmccommandsRequest($userid, $remote_client_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getrmccommands'
     *
     * @param  string $userid User email id (required)
     * @param  string $remote_client_id Remote Client Id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getrmccommandsRequest($userid, $remote_client_id)
    {
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling getrmccommands'
            );
        }
        // verify the required parameter 'remote_client_id' is set
        if ($remote_client_id === null || (is_array($remote_client_id) && count($remote_client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_id when calling getrmccommands'
            );
        }

        $resourcePath = '/core/getrmccommands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($userid !== null) {
            $queryParams['userid'] = ObjectSerializer::toQueryValue($userid);
        }
        // query params
        if ($remote_client_id !== null) {
            $queryParams['remote_client_id'] = ObjectSerializer::toQueryValue($remote_client_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation registerclientforrmc
     *
     * RMC_Related_API - registerclientforrmc is used to register a rmc device while logging in using SSO login
     *
     * @param  string $userid Specify the username (required)
     * @param  string $remote_client_id Specify the unique identifier from the client (It can be the device MAC ID or the phone device ID. It just needs to be an unique number that identifies the device). (required)
     * @param  string $remote_client_disp_name Specify the client device name (required)
     * @param  string $remote_client_api_level Set the api-level to 4 (latest required client api-level is 4) (required)
     * @param  string $remote_client_os_type Specify the client OS type (required)
     * @param  string $remote_client_app_version Specify the client app version (required)
     * @param  string $remote_client_os_version Specify the client OS version (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function registerclientforrmc($userid, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version)
    {
        list($response) = $this->registerclientforrmcWithHttpInfo($userid, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version);
        return $response;
    }

    /**
     * Operation registerclientforrmcWithHttpInfo
     *
     * RMC_Related_API - registerclientforrmc is used to register a rmc device while logging in using SSO login
     *
     * @param  string $userid Specify the username (required)
     * @param  string $remote_client_id Specify the unique identifier from the client (It can be the device MAC ID or the phone device ID. It just needs to be an unique number that identifies the device). (required)
     * @param  string $remote_client_disp_name Specify the client device name (required)
     * @param  string $remote_client_api_level Set the api-level to 4 (latest required client api-level is 4) (required)
     * @param  string $remote_client_os_type Specify the client OS type (required)
     * @param  string $remote_client_app_version Specify the client app version (required)
     * @param  string $remote_client_os_version Specify the client OS version (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function registerclientforrmcWithHttpInfo($userid, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->registerclientforrmcRequest($userid, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation registerclientforrmcAsync
     *
     * RMC_Related_API - registerclientforrmc is used to register a rmc device while logging in using SSO login
     *
     * @param  string $userid Specify the username (required)
     * @param  string $remote_client_id Specify the unique identifier from the client (It can be the device MAC ID or the phone device ID. It just needs to be an unique number that identifies the device). (required)
     * @param  string $remote_client_disp_name Specify the client device name (required)
     * @param  string $remote_client_api_level Set the api-level to 4 (latest required client api-level is 4) (required)
     * @param  string $remote_client_os_type Specify the client OS type (required)
     * @param  string $remote_client_app_version Specify the client app version (required)
     * @param  string $remote_client_os_version Specify the client OS version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function registerclientforrmcAsync($userid, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version)
    {
        return $this->registerclientforrmcAsyncWithHttpInfo($userid, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation registerclientforrmcAsyncWithHttpInfo
     *
     * RMC_Related_API - registerclientforrmc is used to register a rmc device while logging in using SSO login
     *
     * @param  string $userid Specify the username (required)
     * @param  string $remote_client_id Specify the unique identifier from the client (It can be the device MAC ID or the phone device ID. It just needs to be an unique number that identifies the device). (required)
     * @param  string $remote_client_disp_name Specify the client device name (required)
     * @param  string $remote_client_api_level Set the api-level to 4 (latest required client api-level is 4) (required)
     * @param  string $remote_client_os_type Specify the client OS type (required)
     * @param  string $remote_client_app_version Specify the client app version (required)
     * @param  string $remote_client_os_version Specify the client OS version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function registerclientforrmcAsyncWithHttpInfo($userid, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->registerclientforrmcRequest($userid, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'registerclientforrmc'
     *
     * @param  string $userid Specify the username (required)
     * @param  string $remote_client_id Specify the unique identifier from the client (It can be the device MAC ID or the phone device ID. It just needs to be an unique number that identifies the device). (required)
     * @param  string $remote_client_disp_name Specify the client device name (required)
     * @param  string $remote_client_api_level Set the api-level to 4 (latest required client api-level is 4) (required)
     * @param  string $remote_client_os_type Specify the client OS type (required)
     * @param  string $remote_client_app_version Specify the client app version (required)
     * @param  string $remote_client_os_version Specify the client OS version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function registerclientforrmcRequest($userid, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version)
    {
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling registerclientforrmc'
            );
        }
        // verify the required parameter 'remote_client_id' is set
        if ($remote_client_id === null || (is_array($remote_client_id) && count($remote_client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_id when calling registerclientforrmc'
            );
        }
        // verify the required parameter 'remote_client_disp_name' is set
        if ($remote_client_disp_name === null || (is_array($remote_client_disp_name) && count($remote_client_disp_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_disp_name when calling registerclientforrmc'
            );
        }
        // verify the required parameter 'remote_client_api_level' is set
        if ($remote_client_api_level === null || (is_array($remote_client_api_level) && count($remote_client_api_level) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_api_level when calling registerclientforrmc'
            );
        }
        // verify the required parameter 'remote_client_os_type' is set
        if ($remote_client_os_type === null || (is_array($remote_client_os_type) && count($remote_client_os_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_os_type when calling registerclientforrmc'
            );
        }
        // verify the required parameter 'remote_client_app_version' is set
        if ($remote_client_app_version === null || (is_array($remote_client_app_version) && count($remote_client_app_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_app_version when calling registerclientforrmc'
            );
        }
        // verify the required parameter 'remote_client_os_version' is set
        if ($remote_client_os_version === null || (is_array($remote_client_os_version) && count($remote_client_os_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_os_version when calling registerclientforrmc'
            );
        }

        $resourcePath = '/core/registerclientforrmc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($userid !== null) {
            $queryParams['userid'] = ObjectSerializer::toQueryValue($userid);
        }
        // query params
        if ($remote_client_id !== null) {
            $queryParams['remote_client_id'] = ObjectSerializer::toQueryValue($remote_client_id);
        }
        // query params
        if ($remote_client_disp_name !== null) {
            $queryParams['remote_client_disp_name'] = ObjectSerializer::toQueryValue($remote_client_disp_name);
        }
        // query params
        if ($remote_client_api_level !== null) {
            $queryParams['remote_client_api_level'] = ObjectSerializer::toQueryValue($remote_client_api_level);
        }
        // query params
        if ($remote_client_os_type !== null) {
            $queryParams['remote_client_os_type'] = ObjectSerializer::toQueryValue($remote_client_os_type);
        }
        // query params
        if ($remote_client_app_version !== null) {
            $queryParams['remote_client_app_version'] = ObjectSerializer::toQueryValue($remote_client_app_version);
        }
        // query params
        if ($remote_client_os_version !== null) {
            $queryParams['remote_client_os_version'] = ObjectSerializer::toQueryValue($remote_client_os_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestdeviceaccess
     *
     * RMC_Related_API - requestdeviceaccess is used to request device access permission before logging in to a client application
     *
     * @param  string $userid Username (required)
     * @param  string $remote_client_id Specify the client id (required)
     * @param  string $remote_client_disp_name Specify the clients display name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function requestdeviceaccess($userid, $remote_client_id, $remote_client_disp_name)
    {
        list($response) = $this->requestdeviceaccessWithHttpInfo($userid, $remote_client_id, $remote_client_disp_name);
        return $response;
    }

    /**
     * Operation requestdeviceaccessWithHttpInfo
     *
     * RMC_Related_API - requestdeviceaccess is used to request device access permission before logging in to a client application
     *
     * @param  string $userid Username (required)
     * @param  string $remote_client_id Specify the client id (required)
     * @param  string $remote_client_disp_name Specify the clients display name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestdeviceaccessWithHttpInfo($userid, $remote_client_id, $remote_client_disp_name)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->requestdeviceaccessRequest($userid, $remote_client_id, $remote_client_disp_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation requestdeviceaccessAsync
     *
     * RMC_Related_API - requestdeviceaccess is used to request device access permission before logging in to a client application
     *
     * @param  string $userid Username (required)
     * @param  string $remote_client_id Specify the client id (required)
     * @param  string $remote_client_disp_name Specify the clients display name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestdeviceaccessAsync($userid, $remote_client_id, $remote_client_disp_name)
    {
        return $this->requestdeviceaccessAsyncWithHttpInfo($userid, $remote_client_id, $remote_client_disp_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestdeviceaccessAsyncWithHttpInfo
     *
     * RMC_Related_API - requestdeviceaccess is used to request device access permission before logging in to a client application
     *
     * @param  string $userid Username (required)
     * @param  string $remote_client_id Specify the client id (required)
     * @param  string $remote_client_disp_name Specify the clients display name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestdeviceaccessAsyncWithHttpInfo($userid, $remote_client_id, $remote_client_disp_name)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->requestdeviceaccessRequest($userid, $remote_client_id, $remote_client_disp_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestdeviceaccess'
     *
     * @param  string $userid Username (required)
     * @param  string $remote_client_id Specify the client id (required)
     * @param  string $remote_client_disp_name Specify the clients display name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function requestdeviceaccessRequest($userid, $remote_client_id, $remote_client_disp_name)
    {
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling requestdeviceaccess'
            );
        }
        // verify the required parameter 'remote_client_id' is set
        if ($remote_client_id === null || (is_array($remote_client_id) && count($remote_client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_id when calling requestdeviceaccess'
            );
        }
        // verify the required parameter 'remote_client_disp_name' is set
        if ($remote_client_disp_name === null || (is_array($remote_client_disp_name) && count($remote_client_disp_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_disp_name when calling requestdeviceaccess'
            );
        }

        $resourcePath = '/core/requestdeviceaccess';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($userid !== null) {
            $queryParams['userid'] = ObjectSerializer::toQueryValue($userid);
        }
        // query params
        if ($remote_client_id !== null) {
            $queryParams['remote_client_id'] = ObjectSerializer::toQueryValue($remote_client_id);
        }
        // query params
        if ($remote_client_disp_name !== null) {
            $queryParams['remote_client_disp_name'] = ObjectSerializer::toQueryValue($remote_client_disp_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rmcloginguest
     *
     * RMC_Related_API - rmcloginguest is a remote client login api
     *
     * @param  string $userid Specify the username (required)
     * @param  string $password Specify the password (required)
     * @param  string $remote_client_id Specify the unique identifier from the client (It can be the device MAC ID or the phone device ID. It just needs to be an unique number that identifies the device). (required)
     * @param  string $remote_client_disp_name Specify the client device name (required)
     * @param  string $remote_client_api_level Set the api-level to 4 (latest required client api-level is 4) (required)
     * @param  string $remote_client_os_type Specify the client OS type (required)
     * @param  string $remote_client_app_version Specify the client app version (required)
     * @param  string $remote_client_os_version Specify the client OS version (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function rmcloginguest($userid, $password, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version)
    {
        list($response) = $this->rmcloginguestWithHttpInfo($userid, $password, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version);
        return $response;
    }

    /**
     * Operation rmcloginguestWithHttpInfo
     *
     * RMC_Related_API - rmcloginguest is a remote client login api
     *
     * @param  string $userid Specify the username (required)
     * @param  string $password Specify the password (required)
     * @param  string $remote_client_id Specify the unique identifier from the client (It can be the device MAC ID or the phone device ID. It just needs to be an unique number that identifies the device). (required)
     * @param  string $remote_client_disp_name Specify the client device name (required)
     * @param  string $remote_client_api_level Set the api-level to 4 (latest required client api-level is 4) (required)
     * @param  string $remote_client_os_type Specify the client OS type (required)
     * @param  string $remote_client_app_version Specify the client app version (required)
     * @param  string $remote_client_os_version Specify the client OS version (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function rmcloginguestWithHttpInfo($userid, $password, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->rmcloginguestRequest($userid, $password, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rmcloginguestAsync
     *
     * RMC_Related_API - rmcloginguest is a remote client login api
     *
     * @param  string $userid Specify the username (required)
     * @param  string $password Specify the password (required)
     * @param  string $remote_client_id Specify the unique identifier from the client (It can be the device MAC ID or the phone device ID. It just needs to be an unique number that identifies the device). (required)
     * @param  string $remote_client_disp_name Specify the client device name (required)
     * @param  string $remote_client_api_level Set the api-level to 4 (latest required client api-level is 4) (required)
     * @param  string $remote_client_os_type Specify the client OS type (required)
     * @param  string $remote_client_app_version Specify the client app version (required)
     * @param  string $remote_client_os_version Specify the client OS version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rmcloginguestAsync($userid, $password, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version)
    {
        return $this->rmcloginguestAsyncWithHttpInfo($userid, $password, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rmcloginguestAsyncWithHttpInfo
     *
     * RMC_Related_API - rmcloginguest is a remote client login api
     *
     * @param  string $userid Specify the username (required)
     * @param  string $password Specify the password (required)
     * @param  string $remote_client_id Specify the unique identifier from the client (It can be the device MAC ID or the phone device ID. It just needs to be an unique number that identifies the device). (required)
     * @param  string $remote_client_disp_name Specify the client device name (required)
     * @param  string $remote_client_api_level Set the api-level to 4 (latest required client api-level is 4) (required)
     * @param  string $remote_client_os_type Specify the client OS type (required)
     * @param  string $remote_client_app_version Specify the client app version (required)
     * @param  string $remote_client_os_version Specify the client OS version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rmcloginguestAsyncWithHttpInfo($userid, $password, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->rmcloginguestRequest($userid, $password, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rmcloginguest'
     *
     * @param  string $userid Specify the username (required)
     * @param  string $password Specify the password (required)
     * @param  string $remote_client_id Specify the unique identifier from the client (It can be the device MAC ID or the phone device ID. It just needs to be an unique number that identifies the device). (required)
     * @param  string $remote_client_disp_name Specify the client device name (required)
     * @param  string $remote_client_api_level Set the api-level to 4 (latest required client api-level is 4) (required)
     * @param  string $remote_client_os_type Specify the client OS type (required)
     * @param  string $remote_client_app_version Specify the client app version (required)
     * @param  string $remote_client_os_version Specify the client OS version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rmcloginguestRequest($userid, $password, $remote_client_id, $remote_client_disp_name, $remote_client_api_level, $remote_client_os_type, $remote_client_app_version, $remote_client_os_version)
    {
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling rmcloginguest'
            );
        }
        // verify the required parameter 'password' is set
        if ($password === null || (is_array($password) && count($password) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $password when calling rmcloginguest'
            );
        }
        // verify the required parameter 'remote_client_id' is set
        if ($remote_client_id === null || (is_array($remote_client_id) && count($remote_client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_id when calling rmcloginguest'
            );
        }
        // verify the required parameter 'remote_client_disp_name' is set
        if ($remote_client_disp_name === null || (is_array($remote_client_disp_name) && count($remote_client_disp_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_disp_name when calling rmcloginguest'
            );
        }
        // verify the required parameter 'remote_client_api_level' is set
        if ($remote_client_api_level === null || (is_array($remote_client_api_level) && count($remote_client_api_level) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_api_level when calling rmcloginguest'
            );
        }
        // verify the required parameter 'remote_client_os_type' is set
        if ($remote_client_os_type === null || (is_array($remote_client_os_type) && count($remote_client_os_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_os_type when calling rmcloginguest'
            );
        }
        // verify the required parameter 'remote_client_app_version' is set
        if ($remote_client_app_version === null || (is_array($remote_client_app_version) && count($remote_client_app_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_app_version when calling rmcloginguest'
            );
        }
        // verify the required parameter 'remote_client_os_version' is set
        if ($remote_client_os_version === null || (is_array($remote_client_os_version) && count($remote_client_os_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remote_client_os_version when calling rmcloginguest'
            );
        }

        $resourcePath = '/core/rmcloginguest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($userid !== null) {
            $queryParams['userid'] = ObjectSerializer::toQueryValue($userid);
        }
        // query params
        if ($password !== null) {
            $queryParams['password'] = ObjectSerializer::toQueryValue($password);
        }
        // query params
        if ($remote_client_id !== null) {
            $queryParams['remote_client_id'] = ObjectSerializer::toQueryValue($remote_client_id);
        }
        // query params
        if ($remote_client_disp_name !== null) {
            $queryParams['remote_client_disp_name'] = ObjectSerializer::toQueryValue($remote_client_disp_name);
        }
        // query params
        if ($remote_client_api_level !== null) {
            $queryParams['remote_client_api_level'] = ObjectSerializer::toQueryValue($remote_client_api_level);
        }
        // query params
        if ($remote_client_os_type !== null) {
            $queryParams['remote_client_os_type'] = ObjectSerializer::toQueryValue($remote_client_os_type);
        }
        // query params
        if ($remote_client_app_version !== null) {
            $queryParams['remote_client_app_version'] = ObjectSerializer::toQueryValue($remote_client_app_version);
        }
        // query params
        if ($remote_client_os_version !== null) {
            $queryParams['remote_client_os_version'] = ObjectSerializer::toQueryValue($remote_client_os_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
