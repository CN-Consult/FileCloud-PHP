<?php
/**
 * ShareApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * FileCloud_User_API
 *
 * FileCloud HTTP API
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ShareApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ShareApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addgrouptoshare
     *
     * Share_Related_API - addgrouptoshare is used to add an existing group to a privately shared file/folder
     *
     * @param  string $groupid Group ID number of the group to be added to private share (required)
     * @param  string $shareid Share ID number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function addgrouptoshare($groupid, $shareid)
    {
        list($response) = $this->addgrouptoshareWithHttpInfo($groupid, $shareid);
        return $response;
    }

    /**
     * Operation addgrouptoshareWithHttpInfo
     *
     * Share_Related_API - addgrouptoshare is used to add an existing group to a privately shared file/folder
     *
     * @param  string $groupid Group ID number of the group to be added to private share (required)
     * @param  string $shareid Share ID number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function addgrouptoshareWithHttpInfo($groupid, $shareid)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->addgrouptoshareRequest($groupid, $shareid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addgrouptoshareAsync
     *
     * Share_Related_API - addgrouptoshare is used to add an existing group to a privately shared file/folder
     *
     * @param  string $groupid Group ID number of the group to be added to private share (required)
     * @param  string $shareid Share ID number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addgrouptoshareAsync($groupid, $shareid)
    {
        return $this->addgrouptoshareAsyncWithHttpInfo($groupid, $shareid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addgrouptoshareAsyncWithHttpInfo
     *
     * Share_Related_API - addgrouptoshare is used to add an existing group to a privately shared file/folder
     *
     * @param  string $groupid Group ID number of the group to be added to private share (required)
     * @param  string $shareid Share ID number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addgrouptoshareAsyncWithHttpInfo($groupid, $shareid)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->addgrouptoshareRequest($groupid, $shareid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addgrouptoshare'
     *
     * @param  string $groupid Group ID number of the group to be added to private share (required)
     * @param  string $shareid Share ID number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addgrouptoshareRequest($groupid, $shareid)
    {
        // verify the required parameter 'groupid' is set
        if ($groupid === null || (is_array($groupid) && count($groupid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupid when calling addgrouptoshare'
            );
        }
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling addgrouptoshare'
            );
        }

        $resourcePath = '/core/addgrouptoshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($groupid !== null) {
            $queryParams['groupid'] = ObjectSerializer::toQueryValue($groupid);
        }
        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addusertoshare
     *
     * Share_Related_API - addusertoshare is used to add an existing user to access the privately shared file/folder
     *
     * @param  string $userid Specify the user&#39;s email id you want to share the file to (required)
     * @param  string $shareid Share ID number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function addusertoshare($userid, $shareid)
    {
        list($response) = $this->addusertoshareWithHttpInfo($userid, $shareid);
        return $response;
    }

    /**
     * Operation addusertoshareWithHttpInfo
     *
     * Share_Related_API - addusertoshare is used to add an existing user to access the privately shared file/folder
     *
     * @param  string $userid Specify the user&#39;s email id you want to share the file to (required)
     * @param  string $shareid Share ID number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function addusertoshareWithHttpInfo($userid, $shareid)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->addusertoshareRequest($userid, $shareid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addusertoshareAsync
     *
     * Share_Related_API - addusertoshare is used to add an existing user to access the privately shared file/folder
     *
     * @param  string $userid Specify the user&#39;s email id you want to share the file to (required)
     * @param  string $shareid Share ID number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addusertoshareAsync($userid, $shareid)
    {
        return $this->addusertoshareAsyncWithHttpInfo($userid, $shareid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addusertoshareAsyncWithHttpInfo
     *
     * Share_Related_API - addusertoshare is used to add an existing user to access the privately shared file/folder
     *
     * @param  string $userid Specify the user&#39;s email id you want to share the file to (required)
     * @param  string $shareid Share ID number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addusertoshareAsyncWithHttpInfo($userid, $shareid)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->addusertoshareRequest($userid, $shareid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addusertoshare'
     *
     * @param  string $userid Specify the user&#39;s email id you want to share the file to (required)
     * @param  string $shareid Share ID number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addusertoshareRequest($userid, $shareid)
    {
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling addusertoshare'
            );
        }
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling addusertoshare'
            );
        }

        $resourcePath = '/core/addusertoshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($userid !== null) {
            $queryParams['userid'] = ObjectSerializer::toQueryValue($userid);
        }
        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createprofileoninvite
     *
     * Share_Related_API - This endpoint allows adding multiple users to a single share in one go
     *
     * @param  string $shareid Id of the share users are being added to. (required)
     * @param  string $users Comma separated list of user emails. (required)
     * @param  string $sendemail Specifies whether the email should be sent to all invited users (this also relies on the System configuration) (optional)
     * @param  string $custom_subject A common, custom subject that will be used for all emails sent to users added to share (optional)
     * @param  string $custom_message A custom message that will be added to saved email templates, replacing the ^MESSAGE^ placeholder. If that placeholder doesn&#39;t exist a separate email containing that message will be sent. (optional)
     * @param  string $adduserstoshare_subject A custom subject for emails sent to existing, non-external (limited) users (optional)
     * @param  string $adduserstoshare_body A custom email body that will be sent to existing, non-external (limited) users (optional)
     * @param  string $addusertoshare_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share. (optional)
     * @param  string $addnewuserstoshare_subject A custom subject for emails sent to invited users that will be added to the system as a non-external (limited) user. (optional)
     * @param  string $addnewuserstoshare_body A custom email body that will be sent to invited users that will be added to the system as a non-external (limited) user. (optional)
     * @param  string $addnewusertoshare_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     * @param  string $adduserstoshare_limited_subject A custom subject for existing, external (limited) users (optional)
     * @param  string $adduserstoshare_limited_body A custom email body that will be sent to existing, external (limited) users (optional)
     * @param  string $addusertoshare_limited_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     * @param  string $addnewuserstoshare_limited_subject A custom subject for emails sent to non-existing, external (limited) users (optional)
     * @param  string $addnewuserstoshare_limited_body A custom email body that will be sent to non-existing, external (limited) users (optional)
     * @param  string $addnewusertoshare_limited_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function createprofileoninvite($shareid, $users, $sendemail = null, $custom_subject = null, $custom_message = null, $adduserstoshare_subject = null, $adduserstoshare_body = null, $addusertoshare_emails = null, $addnewuserstoshare_subject = null, $addnewuserstoshare_body = null, $addnewusertoshare_emails = null, $adduserstoshare_limited_subject = null, $adduserstoshare_limited_body = null, $addusertoshare_limited_emails = null, $addnewuserstoshare_limited_subject = null, $addnewuserstoshare_limited_body = null, $addnewusertoshare_limited_emails = null)
    {
        list($response) = $this->createprofileoninviteWithHttpInfo($shareid, $users, $sendemail, $custom_subject, $custom_message, $adduserstoshare_subject, $adduserstoshare_body, $addusertoshare_emails, $addnewuserstoshare_subject, $addnewuserstoshare_body, $addnewusertoshare_emails, $adduserstoshare_limited_subject, $adduserstoshare_limited_body, $addusertoshare_limited_emails, $addnewuserstoshare_limited_subject, $addnewuserstoshare_limited_body, $addnewusertoshare_limited_emails);
        return $response;
    }

    /**
     * Operation createprofileoninviteWithHttpInfo
     *
     * Share_Related_API - This endpoint allows adding multiple users to a single share in one go
     *
     * @param  string $shareid Id of the share users are being added to. (required)
     * @param  string $users Comma separated list of user emails. (required)
     * @param  string $sendemail Specifies whether the email should be sent to all invited users (this also relies on the System configuration) (optional)
     * @param  string $custom_subject A common, custom subject that will be used for all emails sent to users added to share (optional)
     * @param  string $custom_message A custom message that will be added to saved email templates, replacing the ^MESSAGE^ placeholder. If that placeholder doesn&#39;t exist a separate email containing that message will be sent. (optional)
     * @param  string $adduserstoshare_subject A custom subject for emails sent to existing, non-external (limited) users (optional)
     * @param  string $adduserstoshare_body A custom email body that will be sent to existing, non-external (limited) users (optional)
     * @param  string $addusertoshare_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share. (optional)
     * @param  string $addnewuserstoshare_subject A custom subject for emails sent to invited users that will be added to the system as a non-external (limited) user. (optional)
     * @param  string $addnewuserstoshare_body A custom email body that will be sent to invited users that will be added to the system as a non-external (limited) user. (optional)
     * @param  string $addnewusertoshare_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     * @param  string $adduserstoshare_limited_subject A custom subject for existing, external (limited) users (optional)
     * @param  string $adduserstoshare_limited_body A custom email body that will be sent to existing, external (limited) users (optional)
     * @param  string $addusertoshare_limited_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     * @param  string $addnewuserstoshare_limited_subject A custom subject for emails sent to non-existing, external (limited) users (optional)
     * @param  string $addnewuserstoshare_limited_body A custom email body that will be sent to non-existing, external (limited) users (optional)
     * @param  string $addnewusertoshare_limited_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function createprofileoninviteWithHttpInfo($shareid, $users, $sendemail = null, $custom_subject = null, $custom_message = null, $adduserstoshare_subject = null, $adduserstoshare_body = null, $addusertoshare_emails = null, $addnewuserstoshare_subject = null, $addnewuserstoshare_body = null, $addnewusertoshare_emails = null, $adduserstoshare_limited_subject = null, $adduserstoshare_limited_body = null, $addusertoshare_limited_emails = null, $addnewuserstoshare_limited_subject = null, $addnewuserstoshare_limited_body = null, $addnewusertoshare_limited_emails = null)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->createprofileoninviteRequest($shareid, $users, $sendemail, $custom_subject, $custom_message, $adduserstoshare_subject, $adduserstoshare_body, $addusertoshare_emails, $addnewuserstoshare_subject, $addnewuserstoshare_body, $addnewusertoshare_emails, $adduserstoshare_limited_subject, $adduserstoshare_limited_body, $addusertoshare_limited_emails, $addnewuserstoshare_limited_subject, $addnewuserstoshare_limited_body, $addnewusertoshare_limited_emails);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createprofileoninviteAsync
     *
     * Share_Related_API - This endpoint allows adding multiple users to a single share in one go
     *
     * @param  string $shareid Id of the share users are being added to. (required)
     * @param  string $users Comma separated list of user emails. (required)
     * @param  string $sendemail Specifies whether the email should be sent to all invited users (this also relies on the System configuration) (optional)
     * @param  string $custom_subject A common, custom subject that will be used for all emails sent to users added to share (optional)
     * @param  string $custom_message A custom message that will be added to saved email templates, replacing the ^MESSAGE^ placeholder. If that placeholder doesn&#39;t exist a separate email containing that message will be sent. (optional)
     * @param  string $adduserstoshare_subject A custom subject for emails sent to existing, non-external (limited) users (optional)
     * @param  string $adduserstoshare_body A custom email body that will be sent to existing, non-external (limited) users (optional)
     * @param  string $addusertoshare_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share. (optional)
     * @param  string $addnewuserstoshare_subject A custom subject for emails sent to invited users that will be added to the system as a non-external (limited) user. (optional)
     * @param  string $addnewuserstoshare_body A custom email body that will be sent to invited users that will be added to the system as a non-external (limited) user. (optional)
     * @param  string $addnewusertoshare_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     * @param  string $adduserstoshare_limited_subject A custom subject for existing, external (limited) users (optional)
     * @param  string $adduserstoshare_limited_body A custom email body that will be sent to existing, external (limited) users (optional)
     * @param  string $addusertoshare_limited_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     * @param  string $addnewuserstoshare_limited_subject A custom subject for emails sent to non-existing, external (limited) users (optional)
     * @param  string $addnewuserstoshare_limited_body A custom email body that will be sent to non-existing, external (limited) users (optional)
     * @param  string $addnewusertoshare_limited_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createprofileoninviteAsync($shareid, $users, $sendemail = null, $custom_subject = null, $custom_message = null, $adduserstoshare_subject = null, $adduserstoshare_body = null, $addusertoshare_emails = null, $addnewuserstoshare_subject = null, $addnewuserstoshare_body = null, $addnewusertoshare_emails = null, $adduserstoshare_limited_subject = null, $adduserstoshare_limited_body = null, $addusertoshare_limited_emails = null, $addnewuserstoshare_limited_subject = null, $addnewuserstoshare_limited_body = null, $addnewusertoshare_limited_emails = null)
    {
        return $this->createprofileoninviteAsyncWithHttpInfo($shareid, $users, $sendemail, $custom_subject, $custom_message, $adduserstoshare_subject, $adduserstoshare_body, $addusertoshare_emails, $addnewuserstoshare_subject, $addnewuserstoshare_body, $addnewusertoshare_emails, $adduserstoshare_limited_subject, $adduserstoshare_limited_body, $addusertoshare_limited_emails, $addnewuserstoshare_limited_subject, $addnewuserstoshare_limited_body, $addnewusertoshare_limited_emails)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createprofileoninviteAsyncWithHttpInfo
     *
     * Share_Related_API - This endpoint allows adding multiple users to a single share in one go
     *
     * @param  string $shareid Id of the share users are being added to. (required)
     * @param  string $users Comma separated list of user emails. (required)
     * @param  string $sendemail Specifies whether the email should be sent to all invited users (this also relies on the System configuration) (optional)
     * @param  string $custom_subject A common, custom subject that will be used for all emails sent to users added to share (optional)
     * @param  string $custom_message A custom message that will be added to saved email templates, replacing the ^MESSAGE^ placeholder. If that placeholder doesn&#39;t exist a separate email containing that message will be sent. (optional)
     * @param  string $adduserstoshare_subject A custom subject for emails sent to existing, non-external (limited) users (optional)
     * @param  string $adduserstoshare_body A custom email body that will be sent to existing, non-external (limited) users (optional)
     * @param  string $addusertoshare_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share. (optional)
     * @param  string $addnewuserstoshare_subject A custom subject for emails sent to invited users that will be added to the system as a non-external (limited) user. (optional)
     * @param  string $addnewuserstoshare_body A custom email body that will be sent to invited users that will be added to the system as a non-external (limited) user. (optional)
     * @param  string $addnewusertoshare_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     * @param  string $adduserstoshare_limited_subject A custom subject for existing, external (limited) users (optional)
     * @param  string $adduserstoshare_limited_body A custom email body that will be sent to existing, external (limited) users (optional)
     * @param  string $addusertoshare_limited_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     * @param  string $addnewuserstoshare_limited_subject A custom subject for emails sent to non-existing, external (limited) users (optional)
     * @param  string $addnewuserstoshare_limited_body A custom email body that will be sent to non-existing, external (limited) users (optional)
     * @param  string $addnewusertoshare_limited_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createprofileoninviteAsyncWithHttpInfo($shareid, $users, $sendemail = null, $custom_subject = null, $custom_message = null, $adduserstoshare_subject = null, $adduserstoshare_body = null, $addusertoshare_emails = null, $addnewuserstoshare_subject = null, $addnewuserstoshare_body = null, $addnewusertoshare_emails = null, $adduserstoshare_limited_subject = null, $adduserstoshare_limited_body = null, $addusertoshare_limited_emails = null, $addnewuserstoshare_limited_subject = null, $addnewuserstoshare_limited_body = null, $addnewusertoshare_limited_emails = null)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->createprofileoninviteRequest($shareid, $users, $sendemail, $custom_subject, $custom_message, $adduserstoshare_subject, $adduserstoshare_body, $addusertoshare_emails, $addnewuserstoshare_subject, $addnewuserstoshare_body, $addnewusertoshare_emails, $adduserstoshare_limited_subject, $adduserstoshare_limited_body, $addusertoshare_limited_emails, $addnewuserstoshare_limited_subject, $addnewuserstoshare_limited_body, $addnewusertoshare_limited_emails);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createprofileoninvite'
     *
     * @param  string $shareid Id of the share users are being added to. (required)
     * @param  string $users Comma separated list of user emails. (required)
     * @param  string $sendemail Specifies whether the email should be sent to all invited users (this also relies on the System configuration) (optional)
     * @param  string $custom_subject A common, custom subject that will be used for all emails sent to users added to share (optional)
     * @param  string $custom_message A custom message that will be added to saved email templates, replacing the ^MESSAGE^ placeholder. If that placeholder doesn&#39;t exist a separate email containing that message will be sent. (optional)
     * @param  string $adduserstoshare_subject A custom subject for emails sent to existing, non-external (limited) users (optional)
     * @param  string $adduserstoshare_body A custom email body that will be sent to existing, non-external (limited) users (optional)
     * @param  string $addusertoshare_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share. (optional)
     * @param  string $addnewuserstoshare_subject A custom subject for emails sent to invited users that will be added to the system as a non-external (limited) user. (optional)
     * @param  string $addnewuserstoshare_body A custom email body that will be sent to invited users that will be added to the system as a non-external (limited) user. (optional)
     * @param  string $addnewusertoshare_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     * @param  string $adduserstoshare_limited_subject A custom subject for existing, external (limited) users (optional)
     * @param  string $adduserstoshare_limited_body A custom email body that will be sent to existing, external (limited) users (optional)
     * @param  string $addusertoshare_limited_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     * @param  string $addnewuserstoshare_limited_subject A custom subject for emails sent to non-existing, external (limited) users (optional)
     * @param  string $addnewuserstoshare_limited_body A custom email body that will be sent to non-existing, external (limited) users (optional)
     * @param  string $addnewusertoshare_limited_emails A comma-separated list of additional emails, to whom that email will be sent. NOTE- those users won&#39;t be added to the share! (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createprofileoninviteRequest($shareid, $users, $sendemail = null, $custom_subject = null, $custom_message = null, $adduserstoshare_subject = null, $adduserstoshare_body = null, $addusertoshare_emails = null, $addnewuserstoshare_subject = null, $addnewuserstoshare_body = null, $addnewusertoshare_emails = null, $adduserstoshare_limited_subject = null, $adduserstoshare_limited_body = null, $addusertoshare_limited_emails = null, $addnewuserstoshare_limited_subject = null, $addnewuserstoshare_limited_body = null, $addnewusertoshare_limited_emails = null)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling createprofileoninvite'
            );
        }
        // verify the required parameter 'users' is set
        if ($users === null || (is_array($users) && count($users) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $users when calling createprofileoninvite'
            );
        }

        $resourcePath = '/core/adduserstoshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }
        // query params
        if ($users !== null) {
            $queryParams['users'] = ObjectSerializer::toQueryValue($users);
        }
        // query params
        if ($sendemail !== null) {
            $queryParams['sendemail'] = ObjectSerializer::toQueryValue($sendemail);
        }
        // query params
        if ($custom_subject !== null) {
            $queryParams['custom_subject'] = ObjectSerializer::toQueryValue($custom_subject);
        }
        // query params
        if ($custom_message !== null) {
            $queryParams['custom_message'] = ObjectSerializer::toQueryValue($custom_message);
        }
        // query params
        if ($adduserstoshare_subject !== null) {
            $queryParams['adduserstoshare_subject'] = ObjectSerializer::toQueryValue($adduserstoshare_subject);
        }
        // query params
        if ($adduserstoshare_body !== null) {
            $queryParams['adduserstoshare_body'] = ObjectSerializer::toQueryValue($adduserstoshare_body);
        }
        // query params
        if ($addusertoshare_emails !== null) {
            $queryParams['addusertoshare_emails'] = ObjectSerializer::toQueryValue($addusertoshare_emails);
        }
        // query params
        if ($addnewuserstoshare_subject !== null) {
            $queryParams['addnewuserstoshare_subject'] = ObjectSerializer::toQueryValue($addnewuserstoshare_subject);
        }
        // query params
        if ($addnewuserstoshare_body !== null) {
            $queryParams['addnewuserstoshare_body'] = ObjectSerializer::toQueryValue($addnewuserstoshare_body);
        }
        // query params
        if ($addnewusertoshare_emails !== null) {
            $queryParams['addnewusertoshare_emails'] = ObjectSerializer::toQueryValue($addnewusertoshare_emails);
        }
        // query params
        if ($adduserstoshare_limited_subject !== null) {
            $queryParams['adduserstoshare_limited_subject'] = ObjectSerializer::toQueryValue($adduserstoshare_limited_subject);
        }
        // query params
        if ($adduserstoshare_limited_body !== null) {
            $queryParams['adduserstoshare_limited_body'] = ObjectSerializer::toQueryValue($adduserstoshare_limited_body);
        }
        // query params
        if ($addusertoshare_limited_emails !== null) {
            $queryParams['addusertoshare_limited_emails'] = ObjectSerializer::toQueryValue($addusertoshare_limited_emails);
        }
        // query params
        if ($addnewuserstoshare_limited_subject !== null) {
            $queryParams['addnewuserstoshare_limited_subject'] = ObjectSerializer::toQueryValue($addnewuserstoshare_limited_subject);
        }
        // query params
        if ($addnewuserstoshare_limited_body !== null) {
            $queryParams['addnewuserstoshare_limited_body'] = ObjectSerializer::toQueryValue($addnewuserstoshare_limited_body);
        }
        // query params
        if ($addnewusertoshare_limited_emails !== null) {
            $queryParams['addnewusertoshare_limited_emails'] = ObjectSerializer::toQueryValue($addnewusertoshare_limited_emails);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createprofileoninvite_0
     *
     * Share_Related_API - createprofileoninvite is used to create a new user account for the user who doesn't exist on FC system
     *
     * @param  string $email Specify the emailid of the user to invite (required)
     * @param  string $shareid Specify the share ID of the user to invite (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function createprofileoninvite_0($email, $shareid)
    {
        list($response) = $this->createprofileoninvite_0WithHttpInfo($email, $shareid);
        return $response;
    }

    /**
     * Operation createprofileoninvite_0WithHttpInfo
     *
     * Share_Related_API - createprofileoninvite is used to create a new user account for the user who doesn't exist on FC system
     *
     * @param  string $email Specify the emailid of the user to invite (required)
     * @param  string $shareid Specify the share ID of the user to invite (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function createprofileoninvite_0WithHttpInfo($email, $shareid)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->createprofileoninvite_0Request($email, $shareid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createprofileoninvite_0Async
     *
     * Share_Related_API - createprofileoninvite is used to create a new user account for the user who doesn't exist on FC system
     *
     * @param  string $email Specify the emailid of the user to invite (required)
     * @param  string $shareid Specify the share ID of the user to invite (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createprofileoninvite_0Async($email, $shareid)
    {
        return $this->createprofileoninvite_0AsyncWithHttpInfo($email, $shareid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createprofileoninvite_0AsyncWithHttpInfo
     *
     * Share_Related_API - createprofileoninvite is used to create a new user account for the user who doesn't exist on FC system
     *
     * @param  string $email Specify the emailid of the user to invite (required)
     * @param  string $shareid Specify the share ID of the user to invite (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createprofileoninvite_0AsyncWithHttpInfo($email, $shareid)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->createprofileoninvite_0Request($email, $shareid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createprofileoninvite_0'
     *
     * @param  string $email Specify the emailid of the user to invite (required)
     * @param  string $shareid Specify the share ID of the user to invite (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createprofileoninvite_0Request($email, $shareid)
    {
        // verify the required parameter 'email' is set
        if ($email === null || (is_array($email) && count($email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $email when calling createprofileoninvite_0'
            );
        }
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling createprofileoninvite_0'
            );
        }

        $resourcePath = '/core/createprofileoninvite';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email);
        }
        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletegroupfromshare
     *
     * Share_Related_API - deletegroupfromshare is used to delete a group from the exisiting privately shared file/folder which was already shared to the group previously
     *
     * @param  string $groupid Group Id number (required)
     * @param  string $shareid Share Id number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function deletegroupfromshare($groupid, $shareid)
    {
        list($response) = $this->deletegroupfromshareWithHttpInfo($groupid, $shareid);
        return $response;
    }

    /**
     * Operation deletegroupfromshareWithHttpInfo
     *
     * Share_Related_API - deletegroupfromshare is used to delete a group from the exisiting privately shared file/folder which was already shared to the group previously
     *
     * @param  string $groupid Group Id number (required)
     * @param  string $shareid Share Id number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletegroupfromshareWithHttpInfo($groupid, $shareid)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->deletegroupfromshareRequest($groupid, $shareid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletegroupfromshareAsync
     *
     * Share_Related_API - deletegroupfromshare is used to delete a group from the exisiting privately shared file/folder which was already shared to the group previously
     *
     * @param  string $groupid Group Id number (required)
     * @param  string $shareid Share Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletegroupfromshareAsync($groupid, $shareid)
    {
        return $this->deletegroupfromshareAsyncWithHttpInfo($groupid, $shareid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletegroupfromshareAsyncWithHttpInfo
     *
     * Share_Related_API - deletegroupfromshare is used to delete a group from the exisiting privately shared file/folder which was already shared to the group previously
     *
     * @param  string $groupid Group Id number (required)
     * @param  string $shareid Share Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletegroupfromshareAsyncWithHttpInfo($groupid, $shareid)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->deletegroupfromshareRequest($groupid, $shareid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletegroupfromshare'
     *
     * @param  string $groupid Group Id number (required)
     * @param  string $shareid Share Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletegroupfromshareRequest($groupid, $shareid)
    {
        // verify the required parameter 'groupid' is set
        if ($groupid === null || (is_array($groupid) && count($groupid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupid when calling deletegroupfromshare'
            );
        }
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling deletegroupfromshare'
            );
        }

        $resourcePath = '/core/deletegroupfromshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($groupid !== null) {
            $queryParams['groupid'] = ObjectSerializer::toQueryValue($groupid);
        }
        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteshare
     *
     * Share_Related_API - deleteshare is used to remove the already shared file/folder which was shared to a user previously
     *
     * @param  string $shareid Share Id number of file/folder for which the share has to be removed (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function deleteshare($shareid)
    {
        list($response) = $this->deleteshareWithHttpInfo($shareid);
        return $response;
    }

    /**
     * Operation deleteshareWithHttpInfo
     *
     * Share_Related_API - deleteshare is used to remove the already shared file/folder which was shared to a user previously
     *
     * @param  string $shareid Share Id number of file/folder for which the share has to be removed (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteshareWithHttpInfo($shareid)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->deleteshareRequest($shareid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteshareAsync
     *
     * Share_Related_API - deleteshare is used to remove the already shared file/folder which was shared to a user previously
     *
     * @param  string $shareid Share Id number of file/folder for which the share has to be removed (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteshareAsync($shareid)
    {
        return $this->deleteshareAsyncWithHttpInfo($shareid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteshareAsyncWithHttpInfo
     *
     * Share_Related_API - deleteshare is used to remove the already shared file/folder which was shared to a user previously
     *
     * @param  string $shareid Share Id number of file/folder for which the share has to be removed (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteshareAsyncWithHttpInfo($shareid)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->deleteshareRequest($shareid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteshare'
     *
     * @param  string $shareid Share Id number of file/folder for which the share has to be removed (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteshareRequest($shareid)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling deleteshare'
            );
        }

        $resourcePath = '/core/deleteshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteuserfromshare
     *
     * Share_Related_API - deleteuserfromshare is used to remove a user from a privately shared file/folder
     *
     * @param  string $userid Specify the email id of user to be removed from share (required)
     * @param  string $shareid Share Id number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function deleteuserfromshare($userid, $shareid)
    {
        list($response) = $this->deleteuserfromshareWithHttpInfo($userid, $shareid);
        return $response;
    }

    /**
     * Operation deleteuserfromshareWithHttpInfo
     *
     * Share_Related_API - deleteuserfromshare is used to remove a user from a privately shared file/folder
     *
     * @param  string $userid Specify the email id of user to be removed from share (required)
     * @param  string $shareid Share Id number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteuserfromshareWithHttpInfo($userid, $shareid)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->deleteuserfromshareRequest($userid, $shareid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteuserfromshareAsync
     *
     * Share_Related_API - deleteuserfromshare is used to remove a user from a privately shared file/folder
     *
     * @param  string $userid Specify the email id of user to be removed from share (required)
     * @param  string $shareid Share Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteuserfromshareAsync($userid, $shareid)
    {
        return $this->deleteuserfromshareAsyncWithHttpInfo($userid, $shareid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteuserfromshareAsyncWithHttpInfo
     *
     * Share_Related_API - deleteuserfromshare is used to remove a user from a privately shared file/folder
     *
     * @param  string $userid Specify the email id of user to be removed from share (required)
     * @param  string $shareid Share Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteuserfromshareAsyncWithHttpInfo($userid, $shareid)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->deleteuserfromshareRequest($userid, $shareid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteuserfromshare'
     *
     * @param  string $userid Specify the email id of user to be removed from share (required)
     * @param  string $shareid Share Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteuserfromshareRequest($userid, $shareid)
    {
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling deleteuserfromshare'
            );
        }
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling deleteuserfromshare'
            );
        }

        $resourcePath = '/core/deleteuserfromshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($userid !== null) {
            $queryParams['userid'] = ObjectSerializer::toQueryValue($userid);
        }
        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getemailsubject
     *
     * Share_Related_API - getemailsubject is used to get email subject to send it to the user
     *
     * @param  string $op Operation... Ie, &#39;getemailsubject&#39; (required)
     * @param  string $param Template name (required)
     * @param  string $toemailid To email id (optional)
     * @param  string $keepuserplaceholders When it&#39;s set to 1 the user-related placeholders(^TOEMAILID^ , ^TO^) are not being replaced when fetching the template. Only common, &#39;global&#39; values, are replaced with the values. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Config
     */
    public function getemailsubject($op, $param, $toemailid = null, $keepuserplaceholders = null)
    {
        list($response) = $this->getemailsubjectWithHttpInfo($op, $param, $toemailid, $keepuserplaceholders);
        return $response;
    }

    /**
     * Operation getemailsubjectWithHttpInfo
     *
     * Share_Related_API - getemailsubject is used to get email subject to send it to the user
     *
     * @param  string $op Operation... Ie, &#39;getemailsubject&#39; (required)
     * @param  string $param Template name (required)
     * @param  string $toemailid To email id (optional)
     * @param  string $keepuserplaceholders When it&#39;s set to 1 the user-related placeholders(^TOEMAILID^ , ^TO^) are not being replaced when fetching the template. Only common, &#39;global&#39; values, are replaced with the values. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Config, HTTP status code, HTTP response headers (array of strings)
     */
    public function getemailsubjectWithHttpInfo($op, $param, $toemailid = null, $keepuserplaceholders = null)
    {
        $returnType = '\Swagger\Client\Model\Config';
        $request = $this->getemailsubjectRequest($op, $param, $toemailid, $keepuserplaceholders);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Config',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getemailsubjectAsync
     *
     * Share_Related_API - getemailsubject is used to get email subject to send it to the user
     *
     * @param  string $op Operation... Ie, &#39;getemailsubject&#39; (required)
     * @param  string $param Template name (required)
     * @param  string $toemailid To email id (optional)
     * @param  string $keepuserplaceholders When it&#39;s set to 1 the user-related placeholders(^TOEMAILID^ , ^TO^) are not being replaced when fetching the template. Only common, &#39;global&#39; values, are replaced with the values. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getemailsubjectAsync($op, $param, $toemailid = null, $keepuserplaceholders = null)
    {
        return $this->getemailsubjectAsyncWithHttpInfo($op, $param, $toemailid, $keepuserplaceholders)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getemailsubjectAsyncWithHttpInfo
     *
     * Share_Related_API - getemailsubject is used to get email subject to send it to the user
     *
     * @param  string $op Operation... Ie, &#39;getemailsubject&#39; (required)
     * @param  string $param Template name (required)
     * @param  string $toemailid To email id (optional)
     * @param  string $keepuserplaceholders When it&#39;s set to 1 the user-related placeholders(^TOEMAILID^ , ^TO^) are not being replaced when fetching the template. Only common, &#39;global&#39; values, are replaced with the values. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getemailsubjectAsyncWithHttpInfo($op, $param, $toemailid = null, $keepuserplaceholders = null)
    {
        $returnType = '\Swagger\Client\Model\Config';
        $request = $this->getemailsubjectRequest($op, $param, $toemailid, $keepuserplaceholders);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getemailsubject'
     *
     * @param  string $op Operation... Ie, &#39;getemailsubject&#39; (required)
     * @param  string $param Template name (required)
     * @param  string $toemailid To email id (optional)
     * @param  string $keepuserplaceholders When it&#39;s set to 1 the user-related placeholders(^TOEMAILID^ , ^TO^) are not being replaced when fetching the template. Only common, &#39;global&#39; values, are replaced with the values. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getemailsubjectRequest($op, $param, $toemailid = null, $keepuserplaceholders = null)
    {
        // verify the required parameter 'op' is set
        if ($op === null || (is_array($op) && count($op) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $op when calling getemailsubject'
            );
        }
        // verify the required parameter 'param' is set
        if ($param === null || (is_array($param) && count($param) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $param when calling getemailsubject'
            );
        }

        $resourcePath = '/core/getemailsubject';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($op !== null) {
            $queryParams['op'] = ObjectSerializer::toQueryValue($op);
        }
        // query params
        if ($param !== null) {
            $queryParams['param'] = ObjectSerializer::toQueryValue($param);
        }
        // query params
        if ($toemailid !== null) {
            $queryParams['toemailid'] = ObjectSerializer::toQueryValue($toemailid);
        }
        // query params
        if ($keepuserplaceholders !== null) {
            $queryParams['keepuserplaceholders'] = ObjectSerializer::toQueryValue($keepuserplaceholders);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getemailtemplate
     *
     * Share_Related_API - getemailtemplate is used to get email template to send it to the user
     *
     * @param  string $templatename Template name (required)
     * @param  string $sharename Share name (required)
     * @param  string $shareurl Share URL (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $keepuserplaceholders When it&#39;s set to 1 the user-related placeholders(^TOEMAILID^ , ^TO^) are not being replaced when fetching the template. Only common, &#39;global&#39; values, are replaced with the values. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getemailtemplate($templatename, $sharename, $shareurl, $toemailid, $keepuserplaceholders = null)
    {
        list($response) = $this->getemailtemplateWithHttpInfo($templatename, $sharename, $shareurl, $toemailid, $keepuserplaceholders);
        return $response;
    }

    /**
     * Operation getemailtemplateWithHttpInfo
     *
     * Share_Related_API - getemailtemplate is used to get email template to send it to the user
     *
     * @param  string $templatename Template name (required)
     * @param  string $sharename Share name (required)
     * @param  string $shareurl Share URL (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $keepuserplaceholders When it&#39;s set to 1 the user-related placeholders(^TOEMAILID^ , ^TO^) are not being replaced when fetching the template. Only common, &#39;global&#39; values, are replaced with the values. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getemailtemplateWithHttpInfo($templatename, $sharename, $shareurl, $toemailid, $keepuserplaceholders = null)
    {
        $returnType = 'string';
        $request = $this->getemailtemplateRequest($templatename, $sharename, $shareurl, $toemailid, $keepuserplaceholders);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getemailtemplateAsync
     *
     * Share_Related_API - getemailtemplate is used to get email template to send it to the user
     *
     * @param  string $templatename Template name (required)
     * @param  string $sharename Share name (required)
     * @param  string $shareurl Share URL (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $keepuserplaceholders When it&#39;s set to 1 the user-related placeholders(^TOEMAILID^ , ^TO^) are not being replaced when fetching the template. Only common, &#39;global&#39; values, are replaced with the values. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getemailtemplateAsync($templatename, $sharename, $shareurl, $toemailid, $keepuserplaceholders = null)
    {
        return $this->getemailtemplateAsyncWithHttpInfo($templatename, $sharename, $shareurl, $toemailid, $keepuserplaceholders)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getemailtemplateAsyncWithHttpInfo
     *
     * Share_Related_API - getemailtemplate is used to get email template to send it to the user
     *
     * @param  string $templatename Template name (required)
     * @param  string $sharename Share name (required)
     * @param  string $shareurl Share URL (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $keepuserplaceholders When it&#39;s set to 1 the user-related placeholders(^TOEMAILID^ , ^TO^) are not being replaced when fetching the template. Only common, &#39;global&#39; values, are replaced with the values. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getemailtemplateAsyncWithHttpInfo($templatename, $sharename, $shareurl, $toemailid, $keepuserplaceholders = null)
    {
        $returnType = 'string';
        $request = $this->getemailtemplateRequest($templatename, $sharename, $shareurl, $toemailid, $keepuserplaceholders);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getemailtemplate'
     *
     * @param  string $templatename Template name (required)
     * @param  string $sharename Share name (required)
     * @param  string $shareurl Share URL (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $keepuserplaceholders When it&#39;s set to 1 the user-related placeholders(^TOEMAILID^ , ^TO^) are not being replaced when fetching the template. Only common, &#39;global&#39; values, are replaced with the values. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getemailtemplateRequest($templatename, $sharename, $shareurl, $toemailid, $keepuserplaceholders = null)
    {
        // verify the required parameter 'templatename' is set
        if ($templatename === null || (is_array($templatename) && count($templatename) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $templatename when calling getemailtemplate'
            );
        }
        // verify the required parameter 'sharename' is set
        if ($sharename === null || (is_array($sharename) && count($sharename) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sharename when calling getemailtemplate'
            );
        }
        // verify the required parameter 'shareurl' is set
        if ($shareurl === null || (is_array($shareurl) && count($shareurl) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareurl when calling getemailtemplate'
            );
        }
        // verify the required parameter 'toemailid' is set
        if ($toemailid === null || (is_array($toemailid) && count($toemailid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $toemailid when calling getemailtemplate'
            );
        }

        $resourcePath = '/core/getemailtemplate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($templatename !== null) {
            $queryParams['templatename'] = ObjectSerializer::toQueryValue($templatename);
        }
        // query params
        if ($sharename !== null) {
            $queryParams['sharename'] = ObjectSerializer::toQueryValue($sharename);
        }
        // query params
        if ($shareurl !== null) {
            $queryParams['shareurl'] = ObjectSerializer::toQueryValue($shareurl);
        }
        // query params
        if ($toemailid !== null) {
            $queryParams['toemailid'] = ObjectSerializer::toQueryValue($toemailid);
        }
        // query params
        if ($keepuserplaceholders !== null) {
            $queryParams['keepuserplaceholders'] = ObjectSerializer::toQueryValue($keepuserplaceholders);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getgroupaccessforshare
     *
     * Share_Related_API - getgroupaccessforshare is used to get permission details of a group for shared file/folder
     *
     * @param  string $shareid Share Id number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Groups
     */
    public function getgroupaccessforshare($shareid)
    {
        list($response) = $this->getgroupaccessforshareWithHttpInfo($shareid);
        return $response;
    }

    /**
     * Operation getgroupaccessforshareWithHttpInfo
     *
     * Share_Related_API - getgroupaccessforshare is used to get permission details of a group for shared file/folder
     *
     * @param  string $shareid Share Id number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Groups, HTTP status code, HTTP response headers (array of strings)
     */
    public function getgroupaccessforshareWithHttpInfo($shareid)
    {
        $returnType = '\Swagger\Client\Model\Groups';
        $request = $this->getgroupaccessforshareRequest($shareid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Groups',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getgroupaccessforshareAsync
     *
     * Share_Related_API - getgroupaccessforshare is used to get permission details of a group for shared file/folder
     *
     * @param  string $shareid Share Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getgroupaccessforshareAsync($shareid)
    {
        return $this->getgroupaccessforshareAsyncWithHttpInfo($shareid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getgroupaccessforshareAsyncWithHttpInfo
     *
     * Share_Related_API - getgroupaccessforshare is used to get permission details of a group for shared file/folder
     *
     * @param  string $shareid Share Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getgroupaccessforshareAsyncWithHttpInfo($shareid)
    {
        $returnType = '\Swagger\Client\Model\Groups';
        $request = $this->getgroupaccessforshareRequest($shareid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getgroupaccessforshare'
     *
     * @param  string $shareid Share Id number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getgroupaccessforshareRequest($shareid)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling getgroupaccessforshare'
            );
        }

        $resourcePath = '/core/getgroupaccessforshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getmanageablesharesall
     *
     * Share_Related_API - getmanageablesharesall is used to get details of all the managed shares.
     *
     * @param  string $op Operation API to be performed (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shares
     */
    public function getmanageablesharesall($op)
    {
        list($response) = $this->getmanageablesharesallWithHttpInfo($op);
        return $response;
    }

    /**
     * Operation getmanageablesharesallWithHttpInfo
     *
     * Share_Related_API - getmanageablesharesall is used to get details of all the managed shares.
     *
     * @param  string $op Operation API to be performed (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shares, HTTP status code, HTTP response headers (array of strings)
     */
    public function getmanageablesharesallWithHttpInfo($op)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->getmanageablesharesallRequest($op);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shares',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getmanageablesharesallAsync
     *
     * Share_Related_API - getmanageablesharesall is used to get details of all the managed shares.
     *
     * @param  string $op Operation API to be performed (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getmanageablesharesallAsync($op)
    {
        return $this->getmanageablesharesallAsyncWithHttpInfo($op)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getmanageablesharesallAsyncWithHttpInfo
     *
     * Share_Related_API - getmanageablesharesall is used to get details of all the managed shares.
     *
     * @param  string $op Operation API to be performed (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getmanageablesharesallAsyncWithHttpInfo($op)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->getmanageablesharesallRequest($op);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getmanageablesharesall'
     *
     * @param  string $op Operation API to be performed (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getmanageablesharesallRequest($op)
    {
        // verify the required parameter 'op' is set
        if ($op === null || (is_array($op) && count($op) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $op when calling getmanageablesharesall'
            );
        }

        $resourcePath = '/core/getmanageablesharesall';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($op !== null) {
            $queryParams['op'] = ObjectSerializer::toQueryValue($op);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getmanageablesharesforpath
     *
     * Share_Related_API - getmanageablesharesforpath is used to get information about manageable shares for a particular path.Also shows the shared child paths
     *
     * @param  string $path Path of the shared folder (required)
     * @param  string $showchildpaths Path of the child folders (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shares
     */
    public function getmanageablesharesforpath($path, $showchildpaths)
    {
        list($response) = $this->getmanageablesharesforpathWithHttpInfo($path, $showchildpaths);
        return $response;
    }

    /**
     * Operation getmanageablesharesforpathWithHttpInfo
     *
     * Share_Related_API - getmanageablesharesforpath is used to get information about manageable shares for a particular path.Also shows the shared child paths
     *
     * @param  string $path Path of the shared folder (required)
     * @param  string $showchildpaths Path of the child folders (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shares, HTTP status code, HTTP response headers (array of strings)
     */
    public function getmanageablesharesforpathWithHttpInfo($path, $showchildpaths)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->getmanageablesharesforpathRequest($path, $showchildpaths);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shares',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getmanageablesharesforpathAsync
     *
     * Share_Related_API - getmanageablesharesforpath is used to get information about manageable shares for a particular path.Also shows the shared child paths
     *
     * @param  string $path Path of the shared folder (required)
     * @param  string $showchildpaths Path of the child folders (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getmanageablesharesforpathAsync($path, $showchildpaths)
    {
        return $this->getmanageablesharesforpathAsyncWithHttpInfo($path, $showchildpaths)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getmanageablesharesforpathAsyncWithHttpInfo
     *
     * Share_Related_API - getmanageablesharesforpath is used to get information about manageable shares for a particular path.Also shows the shared child paths
     *
     * @param  string $path Path of the shared folder (required)
     * @param  string $showchildpaths Path of the child folders (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getmanageablesharesforpathAsyncWithHttpInfo($path, $showchildpaths)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->getmanageablesharesforpathRequest($path, $showchildpaths);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getmanageablesharesforpath'
     *
     * @param  string $path Path of the shared folder (required)
     * @param  string $showchildpaths Path of the child folders (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getmanageablesharesforpathRequest($path, $showchildpaths)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getmanageablesharesforpath'
            );
        }
        // verify the required parameter 'showchildpaths' is set
        if ($showchildpaths === null || (is_array($showchildpaths) && count($showchildpaths) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $showchildpaths when calling getmanageablesharesforpath'
            );
        }

        $resourcePath = '/core/getmanageablesharesforpath';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($showchildpaths !== null) {
            $queryParams['showchildpaths'] = ObjectSerializer::toQueryValue($showchildpaths);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getmostactiveshares
     *
     * Share_Related_API - getmostactiveshares is used to get information about the shared item which was accessed more number of times.
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Activeshares
     */
    public function getmostactiveshares()
    {
        list($response) = $this->getmostactivesharesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getmostactivesharesWithHttpInfo
     *
     * Share_Related_API - getmostactiveshares is used to get information about the shared item which was accessed more number of times.
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Activeshares, HTTP status code, HTTP response headers (array of strings)
     */
    public function getmostactivesharesWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Activeshares';
        $request = $this->getmostactivesharesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Activeshares',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getmostactivesharesAsync
     *
     * Share_Related_API - getmostactiveshares is used to get information about the shared item which was accessed more number of times.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getmostactivesharesAsync()
    {
        return $this->getmostactivesharesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getmostactivesharesAsyncWithHttpInfo
     *
     * Share_Related_API - getmostactiveshares is used to get information about the shared item which was accessed more number of times.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getmostactivesharesAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Activeshares';
        $request = $this->getmostactivesharesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getmostactiveshares'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getmostactivesharesRequest()
    {

        $resourcePath = '/core/getmostactiveshares';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getprivateurlforemail
     *
     * Share_Related_API - getprivateurlforemail is used to get a unique and short private url link to access the shared file/folder
     *
     * @param  string $shareid Share Id Number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getprivateurlforemail($shareid)
    {
        list($response) = $this->getprivateurlforemailWithHttpInfo($shareid);
        return $response;
    }

    /**
     * Operation getprivateurlforemailWithHttpInfo
     *
     * Share_Related_API - getprivateurlforemail is used to get a unique and short private url link to access the shared file/folder
     *
     * @param  string $shareid Share Id Number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getprivateurlforemailWithHttpInfo($shareid)
    {
        $returnType = 'string';
        $request = $this->getprivateurlforemailRequest($shareid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getprivateurlforemailAsync
     *
     * Share_Related_API - getprivateurlforemail is used to get a unique and short private url link to access the shared file/folder
     *
     * @param  string $shareid Share Id Number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getprivateurlforemailAsync($shareid)
    {
        return $this->getprivateurlforemailAsyncWithHttpInfo($shareid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getprivateurlforemailAsyncWithHttpInfo
     *
     * Share_Related_API - getprivateurlforemail is used to get a unique and short private url link to access the shared file/folder
     *
     * @param  string $shareid Share Id Number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getprivateurlforemailAsyncWithHttpInfo($shareid)
    {
        $returnType = 'string';
        $request = $this->getprivateurlforemailRequest($shareid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getprivateurlforemail'
     *
     * @param  string $shareid Share Id Number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getprivateurlforemailRequest($shareid)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling getprivateurlforemail'
            );
        }

        $resourcePath = '/core/getprivateurlforemail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['string']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['string'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getpublicshareauthinfo
     *
     * Share_Related_API - getpublicshareauthinfo
     *
     * @param  string $path Specify the share path (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function getpublicshareauthinfo($path)
    {
        list($response) = $this->getpublicshareauthinfoWithHttpInfo($path);
        return $response;
    }

    /**
     * Operation getpublicshareauthinfoWithHttpInfo
     *
     * Share_Related_API - getpublicshareauthinfo
     *
     * @param  string $path Specify the share path (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function getpublicshareauthinfoWithHttpInfo($path)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->getpublicshareauthinfoRequest($path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getpublicshareauthinfoAsync
     *
     * Share_Related_API - getpublicshareauthinfo
     *
     * @param  string $path Specify the share path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getpublicshareauthinfoAsync($path)
    {
        return $this->getpublicshareauthinfoAsyncWithHttpInfo($path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getpublicshareauthinfoAsyncWithHttpInfo
     *
     * Share_Related_API - getpublicshareauthinfo
     *
     * @param  string $path Specify the share path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getpublicshareauthinfoAsyncWithHttpInfo($path)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->getpublicshareauthinfoRequest($path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getpublicshareauthinfo'
     *
     * @param  string $path Specify the share path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getpublicshareauthinfoRequest($path)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getpublicshareauthinfo'
            );
        }

        $resourcePath = '/core/getpublicshareauthinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getrandompassword
     *
     * Share_Related_API - getrandompassword is used to get a random password generated by the FC system in order to access the share
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function getrandompassword()
    {
        list($response) = $this->getrandompasswordWithHttpInfo();
        return $response;
    }

    /**
     * Operation getrandompasswordWithHttpInfo
     *
     * Share_Related_API - getrandompassword is used to get a random password generated by the FC system in order to access the share
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function getrandompasswordWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->getrandompasswordRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getrandompasswordAsync
     *
     * Share_Related_API - getrandompassword is used to get a random password generated by the FC system in order to access the share
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getrandompasswordAsync()
    {
        return $this->getrandompasswordAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getrandompasswordAsyncWithHttpInfo
     *
     * Share_Related_API - getrandompassword is used to get a random password generated by the FC system in order to access the share
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getrandompasswordAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->getrandompasswordRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getrandompassword'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getrandompasswordRequest()
    {

        $resourcePath = '/core/getrandompassword';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getrecentshareactivityforuser
     *
     * Share_Related_API - getrecentshareactivityforuser
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shareactivities
     */
    public function getrecentshareactivityforuser()
    {
        list($response) = $this->getrecentshareactivityforuserWithHttpInfo();
        return $response;
    }

    /**
     * Operation getrecentshareactivityforuserWithHttpInfo
     *
     * Share_Related_API - getrecentshareactivityforuser
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shareactivities, HTTP status code, HTTP response headers (array of strings)
     */
    public function getrecentshareactivityforuserWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Shareactivities';
        $request = $this->getrecentshareactivityforuserRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shareactivities',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getrecentshareactivityforuserAsync
     *
     * Share_Related_API - getrecentshareactivityforuser
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getrecentshareactivityforuserAsync()
    {
        return $this->getrecentshareactivityforuserAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getrecentshareactivityforuserAsyncWithHttpInfo
     *
     * Share_Related_API - getrecentshareactivityforuser
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getrecentshareactivityforuserAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Shareactivities';
        $request = $this->getrecentshareactivityforuserRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getrecentshareactivityforuser'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getrecentshareactivityforuserRequest()
    {

        $resourcePath = '/core/getrecentshareactivityforuser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getshareactivityforshare
     *
     * Share_Related_API - getshareactivityforshare is used to get the list of share activities
     *
     * @param  string $shareid Share ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shareactivities
     */
    public function getshareactivityforshare($shareid)
    {
        list($response) = $this->getshareactivityforshareWithHttpInfo($shareid);
        return $response;
    }

    /**
     * Operation getshareactivityforshareWithHttpInfo
     *
     * Share_Related_API - getshareactivityforshare is used to get the list of share activities
     *
     * @param  string $shareid Share ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shareactivities, HTTP status code, HTTP response headers (array of strings)
     */
    public function getshareactivityforshareWithHttpInfo($shareid)
    {
        $returnType = '\Swagger\Client\Model\Shareactivities';
        $request = $this->getshareactivityforshareRequest($shareid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shareactivities',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getshareactivityforshareAsync
     *
     * Share_Related_API - getshareactivityforshare is used to get the list of share activities
     *
     * @param  string $shareid Share ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getshareactivityforshareAsync($shareid)
    {
        return $this->getshareactivityforshareAsyncWithHttpInfo($shareid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getshareactivityforshareAsyncWithHttpInfo
     *
     * Share_Related_API - getshareactivityforshare is used to get the list of share activities
     *
     * @param  string $shareid Share ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getshareactivityforshareAsyncWithHttpInfo($shareid)
    {
        $returnType = '\Swagger\Client\Model\Shareactivities';
        $request = $this->getshareactivityforshareRequest($shareid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getshareactivityforshare'
     *
     * @param  string $shareid Share ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getshareactivityforshareRequest($shareid)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling getshareactivityforshare'
            );
        }

        $resourcePath = '/core/getshareactivityforshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getshareforid
     *
     * Share_Related_API - getshareforid
     *
     * @param  string $shareid Share Id Number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shares
     */
    public function getshareforid($shareid)
    {
        list($response) = $this->getshareforidWithHttpInfo($shareid);
        return $response;
    }

    /**
     * Operation getshareforidWithHttpInfo
     *
     * Share_Related_API - getshareforid
     *
     * @param  string $shareid Share Id Number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shares, HTTP status code, HTTP response headers (array of strings)
     */
    public function getshareforidWithHttpInfo($shareid)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->getshareforidRequest($shareid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shares',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getshareforidAsync
     *
     * Share_Related_API - getshareforid
     *
     * @param  string $shareid Share Id Number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getshareforidAsync($shareid)
    {
        return $this->getshareforidAsyncWithHttpInfo($shareid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getshareforidAsyncWithHttpInfo
     *
     * Share_Related_API - getshareforid
     *
     * @param  string $shareid Share Id Number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getshareforidAsyncWithHttpInfo($shareid)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->getshareforidRequest($shareid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getshareforid'
     *
     * @param  string $shareid Share Id Number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getshareforidRequest($shareid)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling getshareforid'
            );
        }

        $resourcePath = '/core/getshareforid';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getshareforpath
     *
     * Share_Related_API - getshareforpath is used to get all details of the share by specifying the shared file/folder path
     *
     * @param  string $path Path of shared file/folder to get details (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shares
     */
    public function getshareforpath($path)
    {
        list($response) = $this->getshareforpathWithHttpInfo($path);
        return $response;
    }

    /**
     * Operation getshareforpathWithHttpInfo
     *
     * Share_Related_API - getshareforpath is used to get all details of the share by specifying the shared file/folder path
     *
     * @param  string $path Path of shared file/folder to get details (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shares, HTTP status code, HTTP response headers (array of strings)
     */
    public function getshareforpathWithHttpInfo($path)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->getshareforpathRequest($path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shares',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getshareforpathAsync
     *
     * Share_Related_API - getshareforpath is used to get all details of the share by specifying the shared file/folder path
     *
     * @param  string $path Path of shared file/folder to get details (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getshareforpathAsync($path)
    {
        return $this->getshareforpathAsyncWithHttpInfo($path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getshareforpathAsyncWithHttpInfo
     *
     * Share_Related_API - getshareforpath is used to get all details of the share by specifying the shared file/folder path
     *
     * @param  string $path Path of shared file/folder to get details (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getshareforpathAsyncWithHttpInfo($path)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->getshareforpathRequest($path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getshareforpath'
     *
     * @param  string $path Path of shared file/folder to get details (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getshareforpathRequest($path)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getshareforpath'
            );
        }

        $resourcePath = '/core/getshareforpath';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getsharepassword
     *
     * Share_Related_API - getsharepassword
     *
     * @param  string $shareid Specify the share Id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shares
     */
    public function getsharepassword($shareid)
    {
        list($response) = $this->getsharepasswordWithHttpInfo($shareid);
        return $response;
    }

    /**
     * Operation getsharepasswordWithHttpInfo
     *
     * Share_Related_API - getsharepassword
     *
     * @param  string $shareid Specify the share Id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shares, HTTP status code, HTTP response headers (array of strings)
     */
    public function getsharepasswordWithHttpInfo($shareid)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->getsharepasswordRequest($shareid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shares',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getsharepasswordAsync
     *
     * Share_Related_API - getsharepassword
     *
     * @param  string $shareid Specify the share Id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getsharepasswordAsync($shareid)
    {
        return $this->getsharepasswordAsyncWithHttpInfo($shareid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getsharepasswordAsyncWithHttpInfo
     *
     * Share_Related_API - getsharepassword
     *
     * @param  string $shareid Specify the share Id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getsharepasswordAsyncWithHttpInfo($shareid)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->getsharepasswordRequest($shareid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getsharepassword'
     *
     * @param  string $shareid Specify the share Id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getsharepasswordRequest($shareid)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling getsharepassword'
            );
        }

        $resourcePath = '/core/getsharepassword';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getshares
     *
     * Share_Related_API - getshares is used to get information about all the shares done in a system
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shares
     */
    public function getshares()
    {
        list($response) = $this->getsharesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getsharesWithHttpInfo
     *
     * Share_Related_API - getshares is used to get information about all the shares done in a system
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shares, HTTP status code, HTTP response headers (array of strings)
     */
    public function getsharesWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->getsharesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shares',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getsharesAsync
     *
     * Share_Related_API - getshares is used to get information about all the shares done in a system
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getsharesAsync()
    {
        return $this->getsharesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getsharesAsyncWithHttpInfo
     *
     * Share_Related_API - getshares is used to get information about all the shares done in a system
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getsharesAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->getsharesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getshares'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getsharesRequest()
    {

        $resourcePath = '/core/getshares';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getsharesfilter
     *
     * Share_Related_API - getsharesfilter is used to get information about the shares done in a system by specifying the path
     *
     * @param  string $location Specify the location with the filename to be shared (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shares
     */
    public function getsharesfilter($location)
    {
        list($response) = $this->getsharesfilterWithHttpInfo($location);
        return $response;
    }

    /**
     * Operation getsharesfilterWithHttpInfo
     *
     * Share_Related_API - getsharesfilter is used to get information about the shares done in a system by specifying the path
     *
     * @param  string $location Specify the location with the filename to be shared (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shares, HTTP status code, HTTP response headers (array of strings)
     */
    public function getsharesfilterWithHttpInfo($location)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->getsharesfilterRequest($location);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shares',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getsharesfilterAsync
     *
     * Share_Related_API - getsharesfilter is used to get information about the shares done in a system by specifying the path
     *
     * @param  string $location Specify the location with the filename to be shared (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getsharesfilterAsync($location)
    {
        return $this->getsharesfilterAsyncWithHttpInfo($location)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getsharesfilterAsyncWithHttpInfo
     *
     * Share_Related_API - getsharesfilter is used to get information about the shares done in a system by specifying the path
     *
     * @param  string $location Specify the location with the filename to be shared (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getsharesfilterAsyncWithHttpInfo($location)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->getsharesfilterRequest($location);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getsharesfilter'
     *
     * @param  string $location Specify the location with the filename to be shared (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getsharesfilterRequest($location)
    {
        // verify the required parameter 'location' is set
        if ($location === null || (is_array($location) && count($location) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location when calling getsharesfilter'
            );
        }

        $resourcePath = '/core/getsharesfilter';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($location !== null) {
            $queryParams['location'] = ObjectSerializer::toQueryValue($location);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getuploadform
     *
     * Share_Related_API - getuploadform is used to get a upload form for a publicly shared folder with upload permission
     *
     * @param  string $shareid Share Id Number of the publicly shared folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getuploadform($shareid)
    {
        list($response) = $this->getuploadformWithHttpInfo($shareid);
        return $response;
    }

    /**
     * Operation getuploadformWithHttpInfo
     *
     * Share_Related_API - getuploadform is used to get a upload form for a publicly shared folder with upload permission
     *
     * @param  string $shareid Share Id Number of the publicly shared folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getuploadformWithHttpInfo($shareid)
    {
        $returnType = 'string';
        $request = $this->getuploadformRequest($shareid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getuploadformAsync
     *
     * Share_Related_API - getuploadform is used to get a upload form for a publicly shared folder with upload permission
     *
     * @param  string $shareid Share Id Number of the publicly shared folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getuploadformAsync($shareid)
    {
        return $this->getuploadformAsyncWithHttpInfo($shareid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getuploadformAsyncWithHttpInfo
     *
     * Share_Related_API - getuploadform is used to get a upload form for a publicly shared folder with upload permission
     *
     * @param  string $shareid Share Id Number of the publicly shared folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getuploadformAsyncWithHttpInfo($shareid)
    {
        $returnType = 'string';
        $request = $this->getuploadformRequest($shareid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getuploadform'
     *
     * @param  string $shareid Share Id Number of the publicly shared folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getuploadformRequest($shareid)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling getuploadform'
            );
        }

        $resourcePath = '/core/getuploadform';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['string']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['string'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation geturlforemail
     *
     * Share_Related_API - geturlforemail is used to get a share url link while sharing the file/folder through email
     *
     * @param  string $shareid Share Id Number (required)
     * @param  string $sharename Share Name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function geturlforemail($shareid, $sharename)
    {
        list($response) = $this->geturlforemailWithHttpInfo($shareid, $sharename);
        return $response;
    }

    /**
     * Operation geturlforemailWithHttpInfo
     *
     * Share_Related_API - geturlforemail is used to get a share url link while sharing the file/folder through email
     *
     * @param  string $shareid Share Id Number (required)
     * @param  string $sharename Share Name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function geturlforemailWithHttpInfo($shareid, $sharename)
    {
        $returnType = 'string';
        $request = $this->geturlforemailRequest($shareid, $sharename);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation geturlforemailAsync
     *
     * Share_Related_API - geturlforemail is used to get a share url link while sharing the file/folder through email
     *
     * @param  string $shareid Share Id Number (required)
     * @param  string $sharename Share Name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function geturlforemailAsync($shareid, $sharename)
    {
        return $this->geturlforemailAsyncWithHttpInfo($shareid, $sharename)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation geturlforemailAsyncWithHttpInfo
     *
     * Share_Related_API - geturlforemail is used to get a share url link while sharing the file/folder through email
     *
     * @param  string $shareid Share Id Number (required)
     * @param  string $sharename Share Name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function geturlforemailAsyncWithHttpInfo($shareid, $sharename)
    {
        $returnType = 'string';
        $request = $this->geturlforemailRequest($shareid, $sharename);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'geturlforemail'
     *
     * @param  string $shareid Share Id Number (required)
     * @param  string $sharename Share Name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function geturlforemailRequest($shareid, $sharename)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling geturlforemail'
            );
        }
        // verify the required parameter 'sharename' is set
        if ($sharename === null || (is_array($sharename) && count($sharename) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sharename when calling geturlforemail'
            );
        }

        $resourcePath = '/core/geturlforemail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }
        // query params
        if ($sharename !== null) {
            $queryParams['sharename'] = ObjectSerializer::toQueryValue($sharename);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['string']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['string'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getuseraccessforshare
     *
     * Share_Related_API - getuseraccessforshare is used to get permission details of a user for a shared file/folder
     *
     * @param  string $shareid Share Id Number of the shared file/folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Users
     */
    public function getuseraccessforshare($shareid)
    {
        list($response) = $this->getuseraccessforshareWithHttpInfo($shareid);
        return $response;
    }

    /**
     * Operation getuseraccessforshareWithHttpInfo
     *
     * Share_Related_API - getuseraccessforshare is used to get permission details of a user for a shared file/folder
     *
     * @param  string $shareid Share Id Number of the shared file/folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Users, HTTP status code, HTTP response headers (array of strings)
     */
    public function getuseraccessforshareWithHttpInfo($shareid)
    {
        $returnType = '\Swagger\Client\Model\Users';
        $request = $this->getuseraccessforshareRequest($shareid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Users',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getuseraccessforshareAsync
     *
     * Share_Related_API - getuseraccessforshare is used to get permission details of a user for a shared file/folder
     *
     * @param  string $shareid Share Id Number of the shared file/folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getuseraccessforshareAsync($shareid)
    {
        return $this->getuseraccessforshareAsyncWithHttpInfo($shareid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getuseraccessforshareAsyncWithHttpInfo
     *
     * Share_Related_API - getuseraccessforshare is used to get permission details of a user for a shared file/folder
     *
     * @param  string $shareid Share Id Number of the shared file/folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getuseraccessforshareAsyncWithHttpInfo($shareid)
    {
        $returnType = '\Swagger\Client\Model\Users';
        $request = $this->getuseraccessforshareRequest($shareid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getuseraccessforshare'
     *
     * @param  string $shareid Share Id Number of the shared file/folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getuseraccessforshareRequest($shareid)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling getuseraccessforshare'
            );
        }

        $resourcePath = '/core/getuseraccessforshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation leaveshare
     *
     * Share_Related_API - leaveshare is used to leave from an already shared file/folder by a user
     *
     * @param  string $path Path of the shared file/folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function leaveshare($path)
    {
        list($response) = $this->leaveshareWithHttpInfo($path);
        return $response;
    }

    /**
     * Operation leaveshareWithHttpInfo
     *
     * Share_Related_API - leaveshare is used to leave from an already shared file/folder by a user
     *
     * @param  string $path Path of the shared file/folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaveshareWithHttpInfo($path)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->leaveshareRequest($path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leaveshareAsync
     *
     * Share_Related_API - leaveshare is used to leave from an already shared file/folder by a user
     *
     * @param  string $path Path of the shared file/folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveshareAsync($path)
    {
        return $this->leaveshareAsyncWithHttpInfo($path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaveshareAsyncWithHttpInfo
     *
     * Share_Related_API - leaveshare is used to leave from an already shared file/folder by a user
     *
     * @param  string $path Path of the shared file/folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveshareAsyncWithHttpInfo($path)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->leaveshareRequest($path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaveshare'
     *
     * @param  string $path Path of the shared file/folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function leaveshareRequest($path)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling leaveshare'
            );
        }

        $resourcePath = '/core/leaveshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation loginprotectedshare
     *
     * Share_Related_API - loginprotectedshare is used to login to access the protected share
     *
     * @param  string $fullquerystring Specify the full query string (required)
     * @param  string $password Password for protected share (required)
     * @param  string $path Specify the shared path (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function loginprotectedshare($fullquerystring, $password, $path)
    {
        list($response) = $this->loginprotectedshareWithHttpInfo($fullquerystring, $password, $path);
        return $response;
    }

    /**
     * Operation loginprotectedshareWithHttpInfo
     *
     * Share_Related_API - loginprotectedshare is used to login to access the protected share
     *
     * @param  string $fullquerystring Specify the full query string (required)
     * @param  string $password Password for protected share (required)
     * @param  string $path Specify the shared path (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function loginprotectedshareWithHttpInfo($fullquerystring, $password, $path)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->loginprotectedshareRequest($fullquerystring, $password, $path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation loginprotectedshareAsync
     *
     * Share_Related_API - loginprotectedshare is used to login to access the protected share
     *
     * @param  string $fullquerystring Specify the full query string (required)
     * @param  string $password Password for protected share (required)
     * @param  string $path Specify the shared path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function loginprotectedshareAsync($fullquerystring, $password, $path)
    {
        return $this->loginprotectedshareAsyncWithHttpInfo($fullquerystring, $password, $path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation loginprotectedshareAsyncWithHttpInfo
     *
     * Share_Related_API - loginprotectedshare is used to login to access the protected share
     *
     * @param  string $fullquerystring Specify the full query string (required)
     * @param  string $password Password for protected share (required)
     * @param  string $path Specify the shared path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function loginprotectedshareAsyncWithHttpInfo($fullquerystring, $password, $path)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->loginprotectedshareRequest($fullquerystring, $password, $path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'loginprotectedshare'
     *
     * @param  string $fullquerystring Specify the full query string (required)
     * @param  string $password Password for protected share (required)
     * @param  string $path Specify the shared path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function loginprotectedshareRequest($fullquerystring, $password, $path)
    {
        // verify the required parameter 'fullquerystring' is set
        if ($fullquerystring === null || (is_array($fullquerystring) && count($fullquerystring) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fullquerystring when calling loginprotectedshare'
            );
        }
        // verify the required parameter 'password' is set
        if ($password === null || (is_array($password) && count($password) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $password when calling loginprotectedshare'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling loginprotectedshare'
            );
        }

        $resourcePath = '/core/loginprotectedshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fullquerystring !== null) {
            $queryParams['fullquerystring'] = ObjectSerializer::toQueryValue($fullquerystring);
        }
        // query params
        if ($password !== null) {
            $queryParams['password'] = ObjectSerializer::toQueryValue($password);
        }
        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quickshare
     *
     * Share_Related_API - quickshare is used to share files to a user by generating link in system
     *
     * @param  string $sharelocation Specify the location with the filename to be shared (required)
     * @param  string $showadvancedsharedialog whether advanced share dialog should be displayed or no. Vales can be 0 or 1(0 - when a new public share is created, 1 - otherwise (a new private share is created or an existing share is being accessed)) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shares
     */
    public function quickshare($sharelocation, $showadvancedsharedialog = null)
    {
        list($response) = $this->quickshareWithHttpInfo($sharelocation, $showadvancedsharedialog);
        return $response;
    }

    /**
     * Operation quickshareWithHttpInfo
     *
     * Share_Related_API - quickshare is used to share files to a user by generating link in system
     *
     * @param  string $sharelocation Specify the location with the filename to be shared (required)
     * @param  string $showadvancedsharedialog whether advanced share dialog should be displayed or no. Vales can be 0 or 1(0 - when a new public share is created, 1 - otherwise (a new private share is created or an existing share is being accessed)) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shares, HTTP status code, HTTP response headers (array of strings)
     */
    public function quickshareWithHttpInfo($sharelocation, $showadvancedsharedialog = null)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->quickshareRequest($sharelocation, $showadvancedsharedialog);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shares',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation quickshareAsync
     *
     * Share_Related_API - quickshare is used to share files to a user by generating link in system
     *
     * @param  string $sharelocation Specify the location with the filename to be shared (required)
     * @param  string $showadvancedsharedialog whether advanced share dialog should be displayed or no. Vales can be 0 or 1(0 - when a new public share is created, 1 - otherwise (a new private share is created or an existing share is being accessed)) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickshareAsync($sharelocation, $showadvancedsharedialog = null)
    {
        return $this->quickshareAsyncWithHttpInfo($sharelocation, $showadvancedsharedialog)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quickshareAsyncWithHttpInfo
     *
     * Share_Related_API - quickshare is used to share files to a user by generating link in system
     *
     * @param  string $sharelocation Specify the location with the filename to be shared (required)
     * @param  string $showadvancedsharedialog whether advanced share dialog should be displayed or no. Vales can be 0 or 1(0 - when a new public share is created, 1 - otherwise (a new private share is created or an existing share is being accessed)) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickshareAsyncWithHttpInfo($sharelocation, $showadvancedsharedialog = null)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->quickshareRequest($sharelocation, $showadvancedsharedialog);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quickshare'
     *
     * @param  string $sharelocation Specify the location with the filename to be shared (required)
     * @param  string $showadvancedsharedialog whether advanced share dialog should be displayed or no. Vales can be 0 or 1(0 - when a new public share is created, 1 - otherwise (a new private share is created or an existing share is being accessed)) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function quickshareRequest($sharelocation, $showadvancedsharedialog = null)
    {
        // verify the required parameter 'sharelocation' is set
        if ($sharelocation === null || (is_array($sharelocation) && count($sharelocation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sharelocation when calling quickshare'
            );
        }

        $resourcePath = '/core/quickshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sharelocation !== null) {
            $queryParams['sharelocation'] = ObjectSerializer::toQueryValue($sharelocation);
        }
        // query params
        if ($showadvancedsharedialog !== null) {
            $queryParams['showadvancedsharedialog'] = ObjectSerializer::toQueryValue($showadvancedsharedialog);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchgroups
     *
     * Share_Related_API - searchgroups is used to search for existing groups in the system in order to add to a shared file or folder
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Searchgroups
     */
    public function searchgroups()
    {
        list($response) = $this->searchgroupsWithHttpInfo();
        return $response;
    }

    /**
     * Operation searchgroupsWithHttpInfo
     *
     * Share_Related_API - searchgroups is used to search for existing groups in the system in order to add to a shared file or folder
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Searchgroups, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchgroupsWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Searchgroups';
        $request = $this->searchgroupsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Searchgroups',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchgroupsAsync
     *
     * Share_Related_API - searchgroups is used to search for existing groups in the system in order to add to a shared file or folder
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchgroupsAsync()
    {
        return $this->searchgroupsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchgroupsAsyncWithHttpInfo
     *
     * Share_Related_API - searchgroups is used to search for existing groups in the system in order to add to a shared file or folder
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchgroupsAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Searchgroups';
        $request = $this->searchgroupsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchgroups'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchgroupsRequest()
    {

        $resourcePath = '/core/searchgroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchprofiles
     *
     * Share_Related_API - searchprofiles is used to search for a user to share a file/folder
     *
     * @param  string $filter Partial name/email for search (required)
     * @param  string $context when context&#x3D;share additional, share-related information is being sent in the response (optional)
     * @param  string $shareid used only when context&#x3D;share (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Profiles
     */
    public function searchprofiles($filter, $context = null, $shareid = null)
    {
        list($response) = $this->searchprofilesWithHttpInfo($filter, $context, $shareid);
        return $response;
    }

    /**
     * Operation searchprofilesWithHttpInfo
     *
     * Share_Related_API - searchprofiles is used to search for a user to share a file/folder
     *
     * @param  string $filter Partial name/email for search (required)
     * @param  string $context when context&#x3D;share additional, share-related information is being sent in the response (optional)
     * @param  string $shareid used only when context&#x3D;share (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Profiles, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchprofilesWithHttpInfo($filter, $context = null, $shareid = null)
    {
        $returnType = '\Swagger\Client\Model\Profiles';
        $request = $this->searchprofilesRequest($filter, $context, $shareid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Profiles',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchprofilesAsync
     *
     * Share_Related_API - searchprofiles is used to search for a user to share a file/folder
     *
     * @param  string $filter Partial name/email for search (required)
     * @param  string $context when context&#x3D;share additional, share-related information is being sent in the response (optional)
     * @param  string $shareid used only when context&#x3D;share (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchprofilesAsync($filter, $context = null, $shareid = null)
    {
        return $this->searchprofilesAsyncWithHttpInfo($filter, $context, $shareid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchprofilesAsyncWithHttpInfo
     *
     * Share_Related_API - searchprofiles is used to search for a user to share a file/folder
     *
     * @param  string $filter Partial name/email for search (required)
     * @param  string $context when context&#x3D;share additional, share-related information is being sent in the response (optional)
     * @param  string $shareid used only when context&#x3D;share (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchprofilesAsyncWithHttpInfo($filter, $context = null, $shareid = null)
    {
        $returnType = '\Swagger\Client\Model\Profiles';
        $request = $this->searchprofilesRequest($filter, $context, $shareid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchprofiles'
     *
     * @param  string $filter Partial name/email for search (required)
     * @param  string $context when context&#x3D;share additional, share-related information is being sent in the response (optional)
     * @param  string $shareid used only when context&#x3D;share (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchprofilesRequest($filter, $context = null, $shareid = null)
    {
        // verify the required parameter 'filter' is set
        if ($filter === null || (is_array($filter) && count($filter) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filter when calling searchprofiles'
            );
        }

        $resourcePath = '/core/searchprofiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context);
        }
        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendemail
     *
     * Share_Related_API - sendemail is used to send email to the user
     *
     * @param  string $from From User Name (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $message Email Template (required)
     * @param  string $subject Subject of the email (required)
     * @param  string $userid User ID (required)
     * @param  string $publicshare Share ID (required)
     * @param  string $replyto Reply To Email ID (required)
     * @param  string $shouldsendemail Email to be sent or not (required)
     * @param  string $bccemailid Email id in bcc field (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Emailstatus
     */
    public function sendemail($from, $toemailid, $message, $subject, $userid, $publicshare, $replyto, $shouldsendemail, $bccemailid)
    {
        list($response) = $this->sendemailWithHttpInfo($from, $toemailid, $message, $subject, $userid, $publicshare, $replyto, $shouldsendemail, $bccemailid);
        return $response;
    }

    /**
     * Operation sendemailWithHttpInfo
     *
     * Share_Related_API - sendemail is used to send email to the user
     *
     * @param  string $from From User Name (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $message Email Template (required)
     * @param  string $subject Subject of the email (required)
     * @param  string $userid User ID (required)
     * @param  string $publicshare Share ID (required)
     * @param  string $replyto Reply To Email ID (required)
     * @param  string $shouldsendemail Email to be sent or not (required)
     * @param  string $bccemailid Email id in bcc field (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Emailstatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendemailWithHttpInfo($from, $toemailid, $message, $subject, $userid, $publicshare, $replyto, $shouldsendemail, $bccemailid)
    {
        $returnType = '\Swagger\Client\Model\Emailstatus';
        $request = $this->sendemailRequest($from, $toemailid, $message, $subject, $userid, $publicshare, $replyto, $shouldsendemail, $bccemailid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Emailstatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendemailAsync
     *
     * Share_Related_API - sendemail is used to send email to the user
     *
     * @param  string $from From User Name (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $message Email Template (required)
     * @param  string $subject Subject of the email (required)
     * @param  string $userid User ID (required)
     * @param  string $publicshare Share ID (required)
     * @param  string $replyto Reply To Email ID (required)
     * @param  string $shouldsendemail Email to be sent or not (required)
     * @param  string $bccemailid Email id in bcc field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendemailAsync($from, $toemailid, $message, $subject, $userid, $publicshare, $replyto, $shouldsendemail, $bccemailid)
    {
        return $this->sendemailAsyncWithHttpInfo($from, $toemailid, $message, $subject, $userid, $publicshare, $replyto, $shouldsendemail, $bccemailid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendemailAsyncWithHttpInfo
     *
     * Share_Related_API - sendemail is used to send email to the user
     *
     * @param  string $from From User Name (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $message Email Template (required)
     * @param  string $subject Subject of the email (required)
     * @param  string $userid User ID (required)
     * @param  string $publicshare Share ID (required)
     * @param  string $replyto Reply To Email ID (required)
     * @param  string $shouldsendemail Email to be sent or not (required)
     * @param  string $bccemailid Email id in bcc field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendemailAsyncWithHttpInfo($from, $toemailid, $message, $subject, $userid, $publicshare, $replyto, $shouldsendemail, $bccemailid)
    {
        $returnType = '\Swagger\Client\Model\Emailstatus';
        $request = $this->sendemailRequest($from, $toemailid, $message, $subject, $userid, $publicshare, $replyto, $shouldsendemail, $bccemailid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendemail'
     *
     * @param  string $from From User Name (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $message Email Template (required)
     * @param  string $subject Subject of the email (required)
     * @param  string $userid User ID (required)
     * @param  string $publicshare Share ID (required)
     * @param  string $replyto Reply To Email ID (required)
     * @param  string $shouldsendemail Email to be sent or not (required)
     * @param  string $bccemailid Email id in bcc field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sendemailRequest($from, $toemailid, $message, $subject, $userid, $publicshare, $replyto, $shouldsendemail, $bccemailid)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling sendemail'
            );
        }
        // verify the required parameter 'toemailid' is set
        if ($toemailid === null || (is_array($toemailid) && count($toemailid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $toemailid when calling sendemail'
            );
        }
        // verify the required parameter 'message' is set
        if ($message === null || (is_array($message) && count($message) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message when calling sendemail'
            );
        }
        // verify the required parameter 'subject' is set
        if ($subject === null || (is_array($subject) && count($subject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subject when calling sendemail'
            );
        }
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling sendemail'
            );
        }
        // verify the required parameter 'publicshare' is set
        if ($publicshare === null || (is_array($publicshare) && count($publicshare) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publicshare when calling sendemail'
            );
        }
        // verify the required parameter 'replyto' is set
        if ($replyto === null || (is_array($replyto) && count($replyto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $replyto when calling sendemail'
            );
        }
        // verify the required parameter 'shouldsendemail' is set
        if ($shouldsendemail === null || (is_array($shouldsendemail) && count($shouldsendemail) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shouldsendemail when calling sendemail'
            );
        }
        // verify the required parameter 'bccemailid' is set
        if ($bccemailid === null || (is_array($bccemailid) && count($bccemailid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bccemailid when calling sendemail'
            );
        }

        $resourcePath = '/core/sendemail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($toemailid !== null) {
            $queryParams['toemailid'] = ObjectSerializer::toQueryValue($toemailid);
        }
        // query params
        if ($message !== null) {
            $queryParams['message'] = ObjectSerializer::toQueryValue($message);
        }
        // query params
        if ($subject !== null) {
            $queryParams['subject'] = ObjectSerializer::toQueryValue($subject);
        }
        // query params
        if ($userid !== null) {
            $queryParams['userid'] = ObjectSerializer::toQueryValue($userid);
        }
        // query params
        if ($publicshare !== null) {
            $queryParams['publicshare'] = ObjectSerializer::toQueryValue($publicshare);
        }
        // query params
        if ($replyto !== null) {
            $queryParams['replyto'] = ObjectSerializer::toQueryValue($replyto);
        }
        // query params
        if ($shouldsendemail !== null) {
            $queryParams['shouldsendemail'] = ObjectSerializer::toQueryValue($shouldsendemail);
        }
        // query params
        if ($bccemailid !== null) {
            $queryParams['bccemailid'] = ObjectSerializer::toQueryValue($bccemailid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendsharetoemail
     *
     * Share_Related_API - sendsharetoemail is used to send the shared file or folder through email
     *
     * @param  string $from From User Name (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $sharename Share name of the file/folder (required)
     * @param  string $sharelocation Share location of the file/folder (required)
     * @param  string $url Share url of the file/folder (required)
     * @param  string $message Email Template (required)
     * @param  string $subject Subject of the email (required)
     * @param  string $userid User ID (required)
     * @param  string $publicshare Share ID (required)
     * @param  string $replyto Reply To Email ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Emailstatus
     */
    public function sendsharetoemail($from, $toemailid, $sharename, $sharelocation, $url, $message, $subject, $userid, $publicshare, $replyto)
    {
        list($response) = $this->sendsharetoemailWithHttpInfo($from, $toemailid, $sharename, $sharelocation, $url, $message, $subject, $userid, $publicshare, $replyto);
        return $response;
    }

    /**
     * Operation sendsharetoemailWithHttpInfo
     *
     * Share_Related_API - sendsharetoemail is used to send the shared file or folder through email
     *
     * @param  string $from From User Name (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $sharename Share name of the file/folder (required)
     * @param  string $sharelocation Share location of the file/folder (required)
     * @param  string $url Share url of the file/folder (required)
     * @param  string $message Email Template (required)
     * @param  string $subject Subject of the email (required)
     * @param  string $userid User ID (required)
     * @param  string $publicshare Share ID (required)
     * @param  string $replyto Reply To Email ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Emailstatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendsharetoemailWithHttpInfo($from, $toemailid, $sharename, $sharelocation, $url, $message, $subject, $userid, $publicshare, $replyto)
    {
        $returnType = '\Swagger\Client\Model\Emailstatus';
        $request = $this->sendsharetoemailRequest($from, $toemailid, $sharename, $sharelocation, $url, $message, $subject, $userid, $publicshare, $replyto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Emailstatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendsharetoemailAsync
     *
     * Share_Related_API - sendsharetoemail is used to send the shared file or folder through email
     *
     * @param  string $from From User Name (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $sharename Share name of the file/folder (required)
     * @param  string $sharelocation Share location of the file/folder (required)
     * @param  string $url Share url of the file/folder (required)
     * @param  string $message Email Template (required)
     * @param  string $subject Subject of the email (required)
     * @param  string $userid User ID (required)
     * @param  string $publicshare Share ID (required)
     * @param  string $replyto Reply To Email ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendsharetoemailAsync($from, $toemailid, $sharename, $sharelocation, $url, $message, $subject, $userid, $publicshare, $replyto)
    {
        return $this->sendsharetoemailAsyncWithHttpInfo($from, $toemailid, $sharename, $sharelocation, $url, $message, $subject, $userid, $publicshare, $replyto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendsharetoemailAsyncWithHttpInfo
     *
     * Share_Related_API - sendsharetoemail is used to send the shared file or folder through email
     *
     * @param  string $from From User Name (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $sharename Share name of the file/folder (required)
     * @param  string $sharelocation Share location of the file/folder (required)
     * @param  string $url Share url of the file/folder (required)
     * @param  string $message Email Template (required)
     * @param  string $subject Subject of the email (required)
     * @param  string $userid User ID (required)
     * @param  string $publicshare Share ID (required)
     * @param  string $replyto Reply To Email ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendsharetoemailAsyncWithHttpInfo($from, $toemailid, $sharename, $sharelocation, $url, $message, $subject, $userid, $publicshare, $replyto)
    {
        $returnType = '\Swagger\Client\Model\Emailstatus';
        $request = $this->sendsharetoemailRequest($from, $toemailid, $sharename, $sharelocation, $url, $message, $subject, $userid, $publicshare, $replyto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendsharetoemail'
     *
     * @param  string $from From User Name (required)
     * @param  string $toemailid To Email ID (required)
     * @param  string $sharename Share name of the file/folder (required)
     * @param  string $sharelocation Share location of the file/folder (required)
     * @param  string $url Share url of the file/folder (required)
     * @param  string $message Email Template (required)
     * @param  string $subject Subject of the email (required)
     * @param  string $userid User ID (required)
     * @param  string $publicshare Share ID (required)
     * @param  string $replyto Reply To Email ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sendsharetoemailRequest($from, $toemailid, $sharename, $sharelocation, $url, $message, $subject, $userid, $publicshare, $replyto)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling sendsharetoemail'
            );
        }
        // verify the required parameter 'toemailid' is set
        if ($toemailid === null || (is_array($toemailid) && count($toemailid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $toemailid when calling sendsharetoemail'
            );
        }
        // verify the required parameter 'sharename' is set
        if ($sharename === null || (is_array($sharename) && count($sharename) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sharename when calling sendsharetoemail'
            );
        }
        // verify the required parameter 'sharelocation' is set
        if ($sharelocation === null || (is_array($sharelocation) && count($sharelocation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sharelocation when calling sendsharetoemail'
            );
        }
        // verify the required parameter 'url' is set
        if ($url === null || (is_array($url) && count($url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling sendsharetoemail'
            );
        }
        // verify the required parameter 'message' is set
        if ($message === null || (is_array($message) && count($message) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message when calling sendsharetoemail'
            );
        }
        // verify the required parameter 'subject' is set
        if ($subject === null || (is_array($subject) && count($subject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subject when calling sendsharetoemail'
            );
        }
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling sendsharetoemail'
            );
        }
        // verify the required parameter 'publicshare' is set
        if ($publicshare === null || (is_array($publicshare) && count($publicshare) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publicshare when calling sendsharetoemail'
            );
        }
        // verify the required parameter 'replyto' is set
        if ($replyto === null || (is_array($replyto) && count($replyto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $replyto when calling sendsharetoemail'
            );
        }

        $resourcePath = '/core/sendsharetoemail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($toemailid !== null) {
            $queryParams['toemailid'] = ObjectSerializer::toQueryValue($toemailid);
        }
        // query params
        if ($sharename !== null) {
            $queryParams['sharename'] = ObjectSerializer::toQueryValue($sharename);
        }
        // query params
        if ($sharelocation !== null) {
            $queryParams['sharelocation'] = ObjectSerializer::toQueryValue($sharelocation);
        }
        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($message !== null) {
            $queryParams['message'] = ObjectSerializer::toQueryValue($message);
        }
        // query params
        if ($subject !== null) {
            $queryParams['subject'] = ObjectSerializer::toQueryValue($subject);
        }
        // query params
        if ($userid !== null) {
            $queryParams['userid'] = ObjectSerializer::toQueryValue($userid);
        }
        // query params
        if ($publicshare !== null) {
            $queryParams['publicshare'] = ObjectSerializer::toQueryValue($publicshare);
        }
        // query params
        if ($replyto !== null) {
            $queryParams['replyto'] = ObjectSerializer::toQueryValue($replyto);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setallowpublicaccess
     *
     * Share_Related_API - setallowpublicaccess is used to set either a private or public access to a shared file
     *
     * @param  string $shareid Share Id number (required)
     * @param  string $allowpublicaccess If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicupload If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicviewonly If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicuploadonly If set to 1 - allow public access , 0 - private access only (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function setallowpublicaccess($shareid, $allowpublicaccess, $allowpublicupload, $allowpublicviewonly, $allowpublicuploadonly)
    {
        list($response) = $this->setallowpublicaccessWithHttpInfo($shareid, $allowpublicaccess, $allowpublicupload, $allowpublicviewonly, $allowpublicuploadonly);
        return $response;
    }

    /**
     * Operation setallowpublicaccessWithHttpInfo
     *
     * Share_Related_API - setallowpublicaccess is used to set either a private or public access to a shared file
     *
     * @param  string $shareid Share Id number (required)
     * @param  string $allowpublicaccess If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicupload If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicviewonly If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicuploadonly If set to 1 - allow public access , 0 - private access only (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function setallowpublicaccessWithHttpInfo($shareid, $allowpublicaccess, $allowpublicupload, $allowpublicviewonly, $allowpublicuploadonly)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->setallowpublicaccessRequest($shareid, $allowpublicaccess, $allowpublicupload, $allowpublicviewonly, $allowpublicuploadonly);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setallowpublicaccessAsync
     *
     * Share_Related_API - setallowpublicaccess is used to set either a private or public access to a shared file
     *
     * @param  string $shareid Share Id number (required)
     * @param  string $allowpublicaccess If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicupload If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicviewonly If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicuploadonly If set to 1 - allow public access , 0 - private access only (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setallowpublicaccessAsync($shareid, $allowpublicaccess, $allowpublicupload, $allowpublicviewonly, $allowpublicuploadonly)
    {
        return $this->setallowpublicaccessAsyncWithHttpInfo($shareid, $allowpublicaccess, $allowpublicupload, $allowpublicviewonly, $allowpublicuploadonly)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setallowpublicaccessAsyncWithHttpInfo
     *
     * Share_Related_API - setallowpublicaccess is used to set either a private or public access to a shared file
     *
     * @param  string $shareid Share Id number (required)
     * @param  string $allowpublicaccess If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicupload If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicviewonly If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicuploadonly If set to 1 - allow public access , 0 - private access only (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setallowpublicaccessAsyncWithHttpInfo($shareid, $allowpublicaccess, $allowpublicupload, $allowpublicviewonly, $allowpublicuploadonly)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->setallowpublicaccessRequest($shareid, $allowpublicaccess, $allowpublicupload, $allowpublicviewonly, $allowpublicuploadonly);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setallowpublicaccess'
     *
     * @param  string $shareid Share Id number (required)
     * @param  string $allowpublicaccess If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicupload If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicviewonly If set to 1 - allow public access , 0 - private access only (required)
     * @param  string $allowpublicuploadonly If set to 1 - allow public access , 0 - private access only (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setallowpublicaccessRequest($shareid, $allowpublicaccess, $allowpublicupload, $allowpublicviewonly, $allowpublicuploadonly)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling setallowpublicaccess'
            );
        }
        // verify the required parameter 'allowpublicaccess' is set
        if ($allowpublicaccess === null || (is_array($allowpublicaccess) && count($allowpublicaccess) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $allowpublicaccess when calling setallowpublicaccess'
            );
        }
        // verify the required parameter 'allowpublicupload' is set
        if ($allowpublicupload === null || (is_array($allowpublicupload) && count($allowpublicupload) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $allowpublicupload when calling setallowpublicaccess'
            );
        }
        // verify the required parameter 'allowpublicviewonly' is set
        if ($allowpublicviewonly === null || (is_array($allowpublicviewonly) && count($allowpublicviewonly) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $allowpublicviewonly when calling setallowpublicaccess'
            );
        }
        // verify the required parameter 'allowpublicuploadonly' is set
        if ($allowpublicuploadonly === null || (is_array($allowpublicuploadonly) && count($allowpublicuploadonly) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $allowpublicuploadonly when calling setallowpublicaccess'
            );
        }

        $resourcePath = '/core/setallowpublicaccess';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }
        // query params
        if ($allowpublicaccess !== null) {
            $queryParams['allowpublicaccess'] = ObjectSerializer::toQueryValue($allowpublicaccess);
        }
        // query params
        if ($allowpublicupload !== null) {
            $queryParams['allowpublicupload'] = ObjectSerializer::toQueryValue($allowpublicupload);
        }
        // query params
        if ($allowpublicviewonly !== null) {
            $queryParams['allowpublicviewonly'] = ObjectSerializer::toQueryValue($allowpublicviewonly);
        }
        // query params
        if ($allowpublicuploadonly !== null) {
            $queryParams['allowpublicuploadonly'] = ObjectSerializer::toQueryValue($allowpublicuploadonly);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setgroupaccessforshare
     *
     * Share_Related_API - setgroupaccessforshare is used to set permission details of a group for shared file/folder
     *
     * @param  string $shareid Share Id (required)
     * @param  string $groupid Group Id (required)
     * @param  string $downloadwritesharesync Set to True or False (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function setgroupaccessforshare($shareid, $groupid, $downloadwritesharesync)
    {
        list($response) = $this->setgroupaccessforshareWithHttpInfo($shareid, $groupid, $downloadwritesharesync);
        return $response;
    }

    /**
     * Operation setgroupaccessforshareWithHttpInfo
     *
     * Share_Related_API - setgroupaccessforshare is used to set permission details of a group for shared file/folder
     *
     * @param  string $shareid Share Id (required)
     * @param  string $groupid Group Id (required)
     * @param  string $downloadwritesharesync Set to True or False (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function setgroupaccessforshareWithHttpInfo($shareid, $groupid, $downloadwritesharesync)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->setgroupaccessforshareRequest($shareid, $groupid, $downloadwritesharesync);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setgroupaccessforshareAsync
     *
     * Share_Related_API - setgroupaccessforshare is used to set permission details of a group for shared file/folder
     *
     * @param  string $shareid Share Id (required)
     * @param  string $groupid Group Id (required)
     * @param  string $downloadwritesharesync Set to True or False (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setgroupaccessforshareAsync($shareid, $groupid, $downloadwritesharesync)
    {
        return $this->setgroupaccessforshareAsyncWithHttpInfo($shareid, $groupid, $downloadwritesharesync)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setgroupaccessforshareAsyncWithHttpInfo
     *
     * Share_Related_API - setgroupaccessforshare is used to set permission details of a group for shared file/folder
     *
     * @param  string $shareid Share Id (required)
     * @param  string $groupid Group Id (required)
     * @param  string $downloadwritesharesync Set to True or False (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setgroupaccessforshareAsyncWithHttpInfo($shareid, $groupid, $downloadwritesharesync)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->setgroupaccessforshareRequest($shareid, $groupid, $downloadwritesharesync);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setgroupaccessforshare'
     *
     * @param  string $shareid Share Id (required)
     * @param  string $groupid Group Id (required)
     * @param  string $downloadwritesharesync Set to True or False (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setgroupaccessforshareRequest($shareid, $groupid, $downloadwritesharesync)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling setgroupaccessforshare'
            );
        }
        // verify the required parameter 'groupid' is set
        if ($groupid === null || (is_array($groupid) && count($groupid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupid when calling setgroupaccessforshare'
            );
        }
        // verify the required parameter 'downloadwritesharesync' is set
        if ($downloadwritesharesync === null || (is_array($downloadwritesharesync) && count($downloadwritesharesync) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $downloadwritesharesync when calling setgroupaccessforshare'
            );
        }

        $resourcePath = '/core/setgroupaccessforshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }
        // query params
        if ($groupid !== null) {
            $queryParams['groupid'] = ObjectSerializer::toQueryValue($groupid);
        }
        // query params
        if ($downloadwritesharesync !== null) {
            $queryParams['download/write/share/sync'] = ObjectSerializer::toQueryValue($downloadwritesharesync);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setuseraccessforshare
     *
     * Share_Related_API - setuseraccessforshare is used to set permission details of a user for shared file/folder
     *
     * @param  string $shareid Share Id (required)
     * @param  string $userid User Id (required)
     * @param  string $downloadwritesharesync Set to True or False (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function setuseraccessforshare($shareid, $userid, $downloadwritesharesync)
    {
        list($response) = $this->setuseraccessforshareWithHttpInfo($shareid, $userid, $downloadwritesharesync);
        return $response;
    }

    /**
     * Operation setuseraccessforshareWithHttpInfo
     *
     * Share_Related_API - setuseraccessforshare is used to set permission details of a user for shared file/folder
     *
     * @param  string $shareid Share Id (required)
     * @param  string $userid User Id (required)
     * @param  string $downloadwritesharesync Set to True or False (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function setuseraccessforshareWithHttpInfo($shareid, $userid, $downloadwritesharesync)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->setuseraccessforshareRequest($shareid, $userid, $downloadwritesharesync);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setuseraccessforshareAsync
     *
     * Share_Related_API - setuseraccessforshare is used to set permission details of a user for shared file/folder
     *
     * @param  string $shareid Share Id (required)
     * @param  string $userid User Id (required)
     * @param  string $downloadwritesharesync Set to True or False (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setuseraccessforshareAsync($shareid, $userid, $downloadwritesharesync)
    {
        return $this->setuseraccessforshareAsyncWithHttpInfo($shareid, $userid, $downloadwritesharesync)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setuseraccessforshareAsyncWithHttpInfo
     *
     * Share_Related_API - setuseraccessforshare is used to set permission details of a user for shared file/folder
     *
     * @param  string $shareid Share Id (required)
     * @param  string $userid User Id (required)
     * @param  string $downloadwritesharesync Set to True or False (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setuseraccessforshareAsyncWithHttpInfo($shareid, $userid, $downloadwritesharesync)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->setuseraccessforshareRequest($shareid, $userid, $downloadwritesharesync);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setuseraccessforshare'
     *
     * @param  string $shareid Share Id (required)
     * @param  string $userid User Id (required)
     * @param  string $downloadwritesharesync Set to True or False (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setuseraccessforshareRequest($shareid, $userid, $downloadwritesharesync)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling setuseraccessforshare'
            );
        }
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling setuseraccessforshare'
            );
        }
        // verify the required parameter 'downloadwritesharesync' is set
        if ($downloadwritesharesync === null || (is_array($downloadwritesharesync) && count($downloadwritesharesync) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $downloadwritesharesync when calling setuseraccessforshare'
            );
        }

        $resourcePath = '/core/setuseraccessforshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }
        // query params
        if ($userid !== null) {
            $queryParams['userid'] = ObjectSerializer::toQueryValue($userid);
        }
        // query params
        if ($downloadwritesharesync !== null) {
            $queryParams['download/write/share/sync'] = ObjectSerializer::toQueryValue($downloadwritesharesync);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation share
     *
     * Share_Related_API - share is used to download a publicly shared file
     *
     * @param  string $mode single file download (required)
     * @param  string $path Shared file path (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function share($mode, $path)
    {
        list($response) = $this->shareWithHttpInfo($mode, $path);
        return $response;
    }

    /**
     * Operation shareWithHttpInfo
     *
     * Share_Related_API - share is used to download a publicly shared file
     *
     * @param  string $mode single file download (required)
     * @param  string $path Shared file path (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function shareWithHttpInfo($mode, $path)
    {
        $returnType = 'string';
        $request = $this->shareRequest($mode, $path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shareAsync
     *
     * Share_Related_API - share is used to download a publicly shared file
     *
     * @param  string $mode single file download (required)
     * @param  string $path Shared file path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shareAsync($mode, $path)
    {
        return $this->shareAsyncWithHttpInfo($mode, $path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shareAsyncWithHttpInfo
     *
     * Share_Related_API - share is used to download a publicly shared file
     *
     * @param  string $mode single file download (required)
     * @param  string $path Shared file path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shareAsyncWithHttpInfo($mode, $path)
    {
        $returnType = 'string';
        $request = $this->shareRequest($mode, $path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'share'
     *
     * @param  string $mode single file download (required)
     * @param  string $path Shared file path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shareRequest($mode, $path)
    {
        // verify the required parameter 'mode' is set
        if ($mode === null || (is_array($mode) && count($mode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mode when calling share'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling share'
            );
        }

        $resourcePath = '/core/share';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateshare
     *
     * Share_Related_API - updateshare is used to update a share information
     *
     * @param  string $shareid Share Id (required)
     * @param  string $sharename Share Name (optional)
     * @param  string $sharelocation Specify the location with the filename/folder to be shared (optional)
     * @param  string $viewmode DEFAULT (optional)
     * @param  string $validityperiod Set the expiry date of share here (optional)
     * @param  object $sharesizelimit Set the size limit for the share (optional)
     * @param  object $maxdownloads Set the maximum times download limit (optional)
     * @param  string $hidenotification Set 1 to disable email notification (optional)
     * @param  string $sharepassword Set the password for protected share (optional)
     * @param  object $allowpublicaccess set as public share or not (optional)
     * @param  object $allowpublicupload set public upload permission (optional)
     * @param  object $allowpublicviewonly set public view permission (optional)
     * @param  object $allowpublicuploadonly set public upload only for the share (optional)
     * @param  object $newshareowner set a new share owner for the share (optional)
     * @param  string $defaultfile set a file in the public share as the default preview for that share (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shares
     */
    public function updateshare($shareid, $sharename = null, $sharelocation = null, $viewmode = null, $validityperiod = null, $sharesizelimit = null, $maxdownloads = null, $hidenotification = null, $sharepassword = null, $allowpublicaccess = null, $allowpublicupload = null, $allowpublicviewonly = null, $allowpublicuploadonly = null, $newshareowner = null, $defaultfile = null)
    {
        list($response) = $this->updateshareWithHttpInfo($shareid, $sharename, $sharelocation, $viewmode, $validityperiod, $sharesizelimit, $maxdownloads, $hidenotification, $sharepassword, $allowpublicaccess, $allowpublicupload, $allowpublicviewonly, $allowpublicuploadonly, $newshareowner, $defaultfile);
        return $response;
    }

    /**
     * Operation updateshareWithHttpInfo
     *
     * Share_Related_API - updateshare is used to update a share information
     *
     * @param  string $shareid Share Id (required)
     * @param  string $sharename Share Name (optional)
     * @param  string $sharelocation Specify the location with the filename/folder to be shared (optional)
     * @param  string $viewmode DEFAULT (optional)
     * @param  string $validityperiod Set the expiry date of share here (optional)
     * @param  object $sharesizelimit Set the size limit for the share (optional)
     * @param  object $maxdownloads Set the maximum times download limit (optional)
     * @param  string $hidenotification Set 1 to disable email notification (optional)
     * @param  string $sharepassword Set the password for protected share (optional)
     * @param  object $allowpublicaccess set as public share or not (optional)
     * @param  object $allowpublicupload set public upload permission (optional)
     * @param  object $allowpublicviewonly set public view permission (optional)
     * @param  object $allowpublicuploadonly set public upload only for the share (optional)
     * @param  object $newshareowner set a new share owner for the share (optional)
     * @param  string $defaultfile set a file in the public share as the default preview for that share (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shares, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateshareWithHttpInfo($shareid, $sharename = null, $sharelocation = null, $viewmode = null, $validityperiod = null, $sharesizelimit = null, $maxdownloads = null, $hidenotification = null, $sharepassword = null, $allowpublicaccess = null, $allowpublicupload = null, $allowpublicviewonly = null, $allowpublicuploadonly = null, $newshareowner = null, $defaultfile = null)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->updateshareRequest($shareid, $sharename, $sharelocation, $viewmode, $validityperiod, $sharesizelimit, $maxdownloads, $hidenotification, $sharepassword, $allowpublicaccess, $allowpublicupload, $allowpublicviewonly, $allowpublicuploadonly, $newshareowner, $defaultfile);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shares',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateshareAsync
     *
     * Share_Related_API - updateshare is used to update a share information
     *
     * @param  string $shareid Share Id (required)
     * @param  string $sharename Share Name (optional)
     * @param  string $sharelocation Specify the location with the filename/folder to be shared (optional)
     * @param  string $viewmode DEFAULT (optional)
     * @param  string $validityperiod Set the expiry date of share here (optional)
     * @param  object $sharesizelimit Set the size limit for the share (optional)
     * @param  object $maxdownloads Set the maximum times download limit (optional)
     * @param  string $hidenotification Set 1 to disable email notification (optional)
     * @param  string $sharepassword Set the password for protected share (optional)
     * @param  object $allowpublicaccess set as public share or not (optional)
     * @param  object $allowpublicupload set public upload permission (optional)
     * @param  object $allowpublicviewonly set public view permission (optional)
     * @param  object $allowpublicuploadonly set public upload only for the share (optional)
     * @param  object $newshareowner set a new share owner for the share (optional)
     * @param  string $defaultfile set a file in the public share as the default preview for that share (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateshareAsync($shareid, $sharename = null, $sharelocation = null, $viewmode = null, $validityperiod = null, $sharesizelimit = null, $maxdownloads = null, $hidenotification = null, $sharepassword = null, $allowpublicaccess = null, $allowpublicupload = null, $allowpublicviewonly = null, $allowpublicuploadonly = null, $newshareowner = null, $defaultfile = null)
    {
        return $this->updateshareAsyncWithHttpInfo($shareid, $sharename, $sharelocation, $viewmode, $validityperiod, $sharesizelimit, $maxdownloads, $hidenotification, $sharepassword, $allowpublicaccess, $allowpublicupload, $allowpublicviewonly, $allowpublicuploadonly, $newshareowner, $defaultfile)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateshareAsyncWithHttpInfo
     *
     * Share_Related_API - updateshare is used to update a share information
     *
     * @param  string $shareid Share Id (required)
     * @param  string $sharename Share Name (optional)
     * @param  string $sharelocation Specify the location with the filename/folder to be shared (optional)
     * @param  string $viewmode DEFAULT (optional)
     * @param  string $validityperiod Set the expiry date of share here (optional)
     * @param  object $sharesizelimit Set the size limit for the share (optional)
     * @param  object $maxdownloads Set the maximum times download limit (optional)
     * @param  string $hidenotification Set 1 to disable email notification (optional)
     * @param  string $sharepassword Set the password for protected share (optional)
     * @param  object $allowpublicaccess set as public share or not (optional)
     * @param  object $allowpublicupload set public upload permission (optional)
     * @param  object $allowpublicviewonly set public view permission (optional)
     * @param  object $allowpublicuploadonly set public upload only for the share (optional)
     * @param  object $newshareowner set a new share owner for the share (optional)
     * @param  string $defaultfile set a file in the public share as the default preview for that share (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateshareAsyncWithHttpInfo($shareid, $sharename = null, $sharelocation = null, $viewmode = null, $validityperiod = null, $sharesizelimit = null, $maxdownloads = null, $hidenotification = null, $sharepassword = null, $allowpublicaccess = null, $allowpublicupload = null, $allowpublicviewonly = null, $allowpublicuploadonly = null, $newshareowner = null, $defaultfile = null)
    {
        $returnType = '\Swagger\Client\Model\Shares';
        $request = $this->updateshareRequest($shareid, $sharename, $sharelocation, $viewmode, $validityperiod, $sharesizelimit, $maxdownloads, $hidenotification, $sharepassword, $allowpublicaccess, $allowpublicupload, $allowpublicviewonly, $allowpublicuploadonly, $newshareowner, $defaultfile);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateshare'
     *
     * @param  string $shareid Share Id (required)
     * @param  string $sharename Share Name (optional)
     * @param  string $sharelocation Specify the location with the filename/folder to be shared (optional)
     * @param  string $viewmode DEFAULT (optional)
     * @param  string $validityperiod Set the expiry date of share here (optional)
     * @param  object $sharesizelimit Set the size limit for the share (optional)
     * @param  object $maxdownloads Set the maximum times download limit (optional)
     * @param  string $hidenotification Set 1 to disable email notification (optional)
     * @param  string $sharepassword Set the password for protected share (optional)
     * @param  object $allowpublicaccess set as public share or not (optional)
     * @param  object $allowpublicupload set public upload permission (optional)
     * @param  object $allowpublicviewonly set public view permission (optional)
     * @param  object $allowpublicuploadonly set public upload only for the share (optional)
     * @param  object $newshareowner set a new share owner for the share (optional)
     * @param  string $defaultfile set a file in the public share as the default preview for that share (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateshareRequest($shareid, $sharename = null, $sharelocation = null, $viewmode = null, $validityperiod = null, $sharesizelimit = null, $maxdownloads = null, $hidenotification = null, $sharepassword = null, $allowpublicaccess = null, $allowpublicupload = null, $allowpublicviewonly = null, $allowpublicuploadonly = null, $newshareowner = null, $defaultfile = null)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling updateshare'
            );
        }

        $resourcePath = '/core/updateshare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }
        // query params
        if ($sharename !== null) {
            $queryParams['sharename'] = ObjectSerializer::toQueryValue($sharename);
        }
        // query params
        if ($sharelocation !== null) {
            $queryParams['sharelocation'] = ObjectSerializer::toQueryValue($sharelocation);
        }
        // query params
        if ($viewmode !== null) {
            $queryParams['viewmode'] = ObjectSerializer::toQueryValue($viewmode);
        }
        // query params
        if ($validityperiod !== null) {
            $queryParams['validityperiod'] = ObjectSerializer::toQueryValue($validityperiod);
        }
        // query params
        if ($sharesizelimit !== null) {
            $queryParams['sharesizelimit'] = ObjectSerializer::toQueryValue($sharesizelimit);
        }
        // query params
        if ($maxdownloads !== null) {
            $queryParams['maxdownloads'] = ObjectSerializer::toQueryValue($maxdownloads);
        }
        // query params
        if ($hidenotification !== null) {
            $queryParams['hidenotification'] = ObjectSerializer::toQueryValue($hidenotification);
        }
        // query params
        if ($sharepassword !== null) {
            $queryParams['sharepassword'] = ObjectSerializer::toQueryValue($sharepassword);
        }
        // query params
        if ($allowpublicaccess !== null) {
            $queryParams['allowpublicaccess'] = ObjectSerializer::toQueryValue($allowpublicaccess);
        }
        // query params
        if ($allowpublicupload !== null) {
            $queryParams['allowpublicupload'] = ObjectSerializer::toQueryValue($allowpublicupload);
        }
        // query params
        if ($allowpublicviewonly !== null) {
            $queryParams['allowpublicviewonly'] = ObjectSerializer::toQueryValue($allowpublicviewonly);
        }
        // query params
        if ($allowpublicuploadonly !== null) {
            $queryParams['allowpublicuploadonly'] = ObjectSerializer::toQueryValue($allowpublicuploadonly);
        }
        // query params
        if ($newshareowner !== null) {
            $queryParams['newshareowner'] = ObjectSerializer::toQueryValue($newshareowner);
        }
        // query params
        if ($defaultfile !== null) {
            $queryParams['defaultfile'] = ObjectSerializer::toQueryValue($defaultfile);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatesharelink
     *
     * Share_Related_API - updatesharelink is used to update the url link of a shared file/folder
     *
     * @param  string $shareid Share Id (required)
     * @param  string $oldsharelink Old share link (required)
     * @param  string $newsharelink New share link (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function updatesharelink($shareid, $oldsharelink, $newsharelink)
    {
        list($response) = $this->updatesharelinkWithHttpInfo($shareid, $oldsharelink, $newsharelink);
        return $response;
    }

    /**
     * Operation updatesharelinkWithHttpInfo
     *
     * Share_Related_API - updatesharelink is used to update the url link of a shared file/folder
     *
     * @param  string $shareid Share Id (required)
     * @param  string $oldsharelink Old share link (required)
     * @param  string $newsharelink New share link (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatesharelinkWithHttpInfo($shareid, $oldsharelink, $newsharelink)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->updatesharelinkRequest($shareid, $oldsharelink, $newsharelink);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatesharelinkAsync
     *
     * Share_Related_API - updatesharelink is used to update the url link of a shared file/folder
     *
     * @param  string $shareid Share Id (required)
     * @param  string $oldsharelink Old share link (required)
     * @param  string $newsharelink New share link (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatesharelinkAsync($shareid, $oldsharelink, $newsharelink)
    {
        return $this->updatesharelinkAsyncWithHttpInfo($shareid, $oldsharelink, $newsharelink)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatesharelinkAsyncWithHttpInfo
     *
     * Share_Related_API - updatesharelink is used to update the url link of a shared file/folder
     *
     * @param  string $shareid Share Id (required)
     * @param  string $oldsharelink Old share link (required)
     * @param  string $newsharelink New share link (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatesharelinkAsyncWithHttpInfo($shareid, $oldsharelink, $newsharelink)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->updatesharelinkRequest($shareid, $oldsharelink, $newsharelink);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatesharelink'
     *
     * @param  string $shareid Share Id (required)
     * @param  string $oldsharelink Old share link (required)
     * @param  string $newsharelink New share link (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatesharelinkRequest($shareid, $oldsharelink, $newsharelink)
    {
        // verify the required parameter 'shareid' is set
        if ($shareid === null || (is_array($shareid) && count($shareid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shareid when calling updatesharelink'
            );
        }
        // verify the required parameter 'oldsharelink' is set
        if ($oldsharelink === null || (is_array($oldsharelink) && count($oldsharelink) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $oldsharelink when calling updatesharelink'
            );
        }
        // verify the required parameter 'newsharelink' is set
        if ($newsharelink === null || (is_array($newsharelink) && count($newsharelink) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $newsharelink when calling updatesharelink'
            );
        }

        $resourcePath = '/core/updatesharelink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($shareid !== null) {
            $queryParams['shareid'] = ObjectSerializer::toQueryValue($shareid);
        }
        // query params
        if ($oldsharelink !== null) {
            $queryParams['oldsharelink'] = ObjectSerializer::toQueryValue($oldsharelink);
        }
        // query params
        if ($newsharelink !== null) {
            $queryParams['newsharelink'] = ObjectSerializer::toQueryValue($newsharelink);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
