<?php
/**
 * FileApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache License v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * FileCloud API
 *
 * The FileCloud APIs provide developers with the tools necessary to build a variety of apps and clients. This allows extensibility and integration of FileCloud with your existing enterprise systems and frameworks. FileCloud developer API is simple to use and integrate.
 *
 * OpenAPI spec version: 18.1.0.682
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * FileApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache License v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class FileApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation cancelSearch
     *
     * @param  string $searchid Specify the search ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function cancelSearch($searchid)
    {
        list($response) = $this->cancelSearchWithHttpInfo($searchid);
        return $response;
    }

    /**
     * Operation cancelSearchWithHttpInfo
     *
     * @param  string $searchid Specify the search ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelSearchWithHttpInfo($searchid)
    {
        $returnType = 'string';
        $request = $this->cancelSearchRequest($searchid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelSearchAsync
     *
     * 
     *
     * @param  string $searchid Specify the search ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelSearchAsync($searchid)
    {
        return $this->cancelSearchAsyncWithHttpInfo($searchid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelSearchAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $searchid Specify the search ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelSearchAsyncWithHttpInfo($searchid)
    {
        $returnType = 'string';
        $request = $this->cancelSearchRequest($searchid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelSearch'
     *
     * @param  string $searchid Specify the search ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelSearchRequest($searchid)
    {
        // verify the required parameter 'searchid' is set
        if ($searchid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchid when calling cancelSearch'
            );
        }

        $resourcePath = '/core/cancelsearch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($searchid !== null) {
            $formParams['searchid'] = ObjectSerializer::toFormValue($searchid);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clearSavedSearchTerms
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function clearSavedSearchTerms()
    {
        list($response) = $this->clearSavedSearchTermsWithHttpInfo();
        return $response;
    }

    /**
     * Operation clearSavedSearchTermsWithHttpInfo
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function clearSavedSearchTermsWithHttpInfo()
    {
        $returnType = 'string';
        $request = $this->clearSavedSearchTermsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clearSavedSearchTermsAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearSavedSearchTermsAsync()
    {
        return $this->clearSavedSearchTermsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clearSavedSearchTermsAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearSavedSearchTermsAsyncWithHttpInfo()
    {
        $returnType = 'string';
        $request = $this->clearSavedSearchTermsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clearSavedSearchTerms'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clearSavedSearchTermsRequest()
    {

        $resourcePath = '/core/clearsavedsearchterms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation copyFile
     *
     * @param  string $copyto Path where the files has to be copied (required)
     * @param  string $path Path where the files reside (required)
     * @param  string $name Name of the image file, eg: /Path/Image file name. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function copyFile($copyto, $path, $name)
    {
        list($response) = $this->copyFileWithHttpInfo($copyto, $path, $name);
        return $response;
    }

    /**
     * Operation copyFileWithHttpInfo
     *
     * @param  string $copyto Path where the files has to be copied (required)
     * @param  string $path Path where the files reside (required)
     * @param  string $name Name of the image file, eg: /Path/Image file name. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyFileWithHttpInfo($copyto, $path, $name)
    {
        $returnType = 'string';
        $request = $this->copyFileRequest($copyto, $path, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation copyFileAsync
     *
     * 
     *
     * @param  string $copyto Path where the files has to be copied (required)
     * @param  string $path Path where the files reside (required)
     * @param  string $name Name of the image file, eg: /Path/Image file name. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFileAsync($copyto, $path, $name)
    {
        return $this->copyFileAsyncWithHttpInfo($copyto, $path, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyFileAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $copyto Path where the files has to be copied (required)
     * @param  string $path Path where the files reside (required)
     * @param  string $name Name of the image file, eg: /Path/Image file name. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFileAsyncWithHttpInfo($copyto, $path, $name)
    {
        $returnType = 'string';
        $request = $this->copyFileRequest($copyto, $path, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyFile'
     *
     * @param  string $copyto Path where the files has to be copied (required)
     * @param  string $path Path where the files reside (required)
     * @param  string $name Name of the image file, eg: /Path/Image file name. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function copyFileRequest($copyto, $path, $name)
    {
        // verify the required parameter 'copyto' is set
        if ($copyto === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $copyto when calling copyFile'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling copyFile'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling copyFile'
            );
        }

        $resourcePath = '/core/copyfile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($copyto !== null) {
            $formParams['copyto'] = ObjectSerializer::toFormValue($copyto);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFolder
     *
     * @param  string $name Name of the folder to be created (required)
     * @param  string $path Path where you want to create the folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function createFolder($name, $path)
    {
        list($response) = $this->createFolderWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation createFolderWithHttpInfo
     *
     * @param  string $name Name of the folder to be created (required)
     * @param  string $path Path where you want to create the folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFolderWithHttpInfo($name, $path)
    {
        $returnType = 'string';
        $request = $this->createFolderRequest($name, $path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createFolderAsync
     *
     * 
     *
     * @param  string $name Name of the folder to be created (required)
     * @param  string $path Path where you want to create the folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFolderAsync($name, $path)
    {
        return $this->createFolderAsyncWithHttpInfo($name, $path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFolderAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name Name of the folder to be created (required)
     * @param  string $path Path where you want to create the folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFolderAsyncWithHttpInfo($name, $path)
    {
        $returnType = 'string';
        $request = $this->createFolderRequest($name, $path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFolder'
     *
     * @param  string $name Name of the folder to be created (required)
     * @param  string $path Path where you want to create the folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createFolderRequest($name, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling createFolder'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling createFolder'
            );
        }

        $resourcePath = '/app/explorer/createfolder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFile
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be deleted. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function deleteFile($path, $name)
    {
        list($response) = $this->deleteFileWithHttpInfo($path, $name);
        return $response;
    }

    /**
     * Operation deleteFileWithHttpInfo
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be deleted. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFileWithHttpInfo($path, $name)
    {
        $returnType = 'string';
        $request = $this->deleteFileRequest($path, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFileAsync
     *
     * 
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsync($path, $name)
    {
        return $this->deleteFileAsyncWithHttpInfo($path, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFileAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsyncWithHttpInfo($path, $name)
    {
        $returnType = 'string';
        $request = $this->deleteFileRequest($path, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFile'
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFileRequest($path, $name)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling deleteFile'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteFile'
            );
        }

        $resourcePath = '/core/deletefile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePartialUploads
     *
     * @param  int $ignorets Set value to 1 to delete partial uploads using API call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function deletePartialUploads($ignorets)
    {
        list($response) = $this->deletePartialUploadsWithHttpInfo($ignorets);
        return $response;
    }

    /**
     * Operation deletePartialUploadsWithHttpInfo
     *
     * @param  int $ignorets Set value to 1 to delete partial uploads using API call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePartialUploadsWithHttpInfo($ignorets)
    {
        $returnType = 'string';
        $request = $this->deletePartialUploadsRequest($ignorets);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePartialUploadsAsync
     *
     * 
     *
     * @param  int $ignorets Set value to 1 to delete partial uploads using API call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePartialUploadsAsync($ignorets)
    {
        return $this->deletePartialUploadsAsyncWithHttpInfo($ignorets)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePartialUploadsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $ignorets Set value to 1 to delete partial uploads using API call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePartialUploadsAsyncWithHttpInfo($ignorets)
    {
        $returnType = 'string';
        $request = $this->deletePartialUploadsRequest($ignorets);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePartialUploads'
     *
     * @param  int $ignorets Set value to 1 to delete partial uploads using API call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePartialUploadsRequest($ignorets)
    {
        // verify the required parameter 'ignorets' is set
        if ($ignorets === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ignorets when calling deletePartialUploads'
            );
        }

        $resourcePath = '/core/deletepartialuploads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($ignorets !== null) {
            $formParams['ignorets'] = ObjectSerializer::toFormValue($ignorets);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation doSearch
     *
     * @param  string $searchstring Keyword to search (required)
     * @param  string $searchloc Specify the directory path in which you want to perform search. (required)
     * @param  string $searchscope Specify the search scope (required)
     * @param  string $start Set to 0 (required)
     * @param  string $size Specify the search record limit value (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function doSearch($searchstring, $searchloc, $searchscope, $start, $size, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        list($response) = $this->doSearchWithHttpInfo($searchstring, $searchloc, $searchscope, $start, $size, $minsize, $maxsize, $modifiedstart, $modifiedend);
        return $response;
    }

    /**
     * Operation doSearchWithHttpInfo
     *
     * @param  string $searchstring Keyword to search (required)
     * @param  string $searchloc Specify the directory path in which you want to perform search. (required)
     * @param  string $searchscope Specify the search scope (required)
     * @param  string $start Set to 0 (required)
     * @param  string $size Specify the search record limit value (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function doSearchWithHttpInfo($searchstring, $searchloc, $searchscope, $start, $size, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        $returnType = 'string';
        $request = $this->doSearchRequest($searchstring, $searchloc, $searchscope, $start, $size, $minsize, $maxsize, $modifiedstart, $modifiedend);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation doSearchAsync
     *
     * 
     *
     * @param  string $searchstring Keyword to search (required)
     * @param  string $searchloc Specify the directory path in which you want to perform search. (required)
     * @param  string $searchscope Specify the search scope (required)
     * @param  string $start Set to 0 (required)
     * @param  string $size Specify the search record limit value (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function doSearchAsync($searchstring, $searchloc, $searchscope, $start, $size, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        return $this->doSearchAsyncWithHttpInfo($searchstring, $searchloc, $searchscope, $start, $size, $minsize, $maxsize, $modifiedstart, $modifiedend)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation doSearchAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $searchstring Keyword to search (required)
     * @param  string $searchloc Specify the directory path in which you want to perform search. (required)
     * @param  string $searchscope Specify the search scope (required)
     * @param  string $start Set to 0 (required)
     * @param  string $size Specify the search record limit value (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function doSearchAsyncWithHttpInfo($searchstring, $searchloc, $searchscope, $start, $size, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        $returnType = 'string';
        $request = $this->doSearchRequest($searchstring, $searchloc, $searchscope, $start, $size, $minsize, $maxsize, $modifiedstart, $modifiedend);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'doSearch'
     *
     * @param  string $searchstring Keyword to search (required)
     * @param  string $searchloc Specify the directory path in which you want to perform search. (required)
     * @param  string $searchscope Specify the search scope (required)
     * @param  string $start Set to 0 (required)
     * @param  string $size Specify the search record limit value (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function doSearchRequest($searchstring, $searchloc, $searchscope, $start, $size, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        // verify the required parameter 'searchstring' is set
        if ($searchstring === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchstring when calling doSearch'
            );
        }
        // verify the required parameter 'searchloc' is set
        if ($searchloc === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchloc when calling doSearch'
            );
        }
        // verify the required parameter 'searchscope' is set
        if ($searchscope === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchscope when calling doSearch'
            );
        }
        // verify the required parameter 'start' is set
        if ($start === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start when calling doSearch'
            );
        }
        // verify the required parameter 'size' is set
        if ($size === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $size when calling doSearch'
            );
        }

        $resourcePath = '/core/dosearch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($searchstring !== null) {
            $formParams['searchstring'] = ObjectSerializer::toFormValue($searchstring);
        }
        // form params
        if ($searchloc !== null) {
            $formParams['searchloc'] = ObjectSerializer::toFormValue($searchloc);
        }
        // form params
        if ($minsize !== null) {
            $formParams['minsize'] = ObjectSerializer::toFormValue($minsize);
        }
        // form params
        if ($maxsize !== null) {
            $formParams['maxsize'] = ObjectSerializer::toFormValue($maxsize);
        }
        // form params
        if ($modifiedstart !== null) {
            $formParams['modifiedstart'] = ObjectSerializer::toFormValue($modifiedstart);
        }
        // form params
        if ($modifiedend !== null) {
            $formParams['modifiedend'] = ObjectSerializer::toFormValue($modifiedend);
        }
        // form params
        if ($searchscope !== null) {
            $formParams['searchscope'] = ObjectSerializer::toFormValue($searchscope);
        }
        // form params
        if ($start !== null) {
            $formParams['start'] = ObjectSerializer::toFormValue($start);
        }
        // form params
        if ($size !== null) {
            $formParams['size'] = ObjectSerializer::toFormValue($size);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation docEdit
     *
     * @param  string $path Path of the file where it resides (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function docEdit($path)
    {
        $this->docEditWithHttpInfo($path);
    }

    /**
     * Operation docEditWithHttpInfo
     *
     * @param  string $path Path of the file where it resides (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function docEditWithHttpInfo($path)
    {
        $returnType = '';
        $request = $this->docEditRequest($path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation docEditAsync
     *
     * 
     *
     * @param  string $path Path of the file where it resides (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function docEditAsync($path)
    {
        return $this->docEditAsyncWithHttpInfo($path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation docEditAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path Path of the file where it resides (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function docEditAsyncWithHttpInfo($path)
    {
        $returnType = '';
        $request = $this->docEditRequest($path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'docEdit'
     *
     * @param  string $path Path of the file where it resides (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function docEditRequest($path)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling docEdit'
            );
        }

        $resourcePath = '/core/docedit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadFile
     *
     * @param  string $filepath Path of the file where it resides and with the name of the file to be downloaded. (required)
     * @param  string $filename Name of the file to be downloaded (required)
     * @param  string $redirect (Optional)Set it to 1 to directly download from Amazon S3 (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function downloadFile($filepath, $filename, $redirect = null)
    {
        $this->downloadFileWithHttpInfo($filepath, $filename, $redirect);
    }

    /**
     * Operation downloadFileWithHttpInfo
     *
     * @param  string $filepath Path of the file where it resides and with the name of the file to be downloaded. (required)
     * @param  string $filename Name of the file to be downloaded (required)
     * @param  string $redirect (Optional)Set it to 1 to directly download from Amazon S3 (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadFileWithHttpInfo($filepath, $filename, $redirect = null)
    {
        $returnType = '';
        $request = $this->downloadFileRequest($filepath, $filename, $redirect);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation downloadFileAsync
     *
     * 
     *
     * @param  string $filepath Path of the file where it resides and with the name of the file to be downloaded. (required)
     * @param  string $filename Name of the file to be downloaded (required)
     * @param  string $redirect (Optional)Set it to 1 to directly download from Amazon S3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFileAsync($filepath, $filename, $redirect = null)
    {
        return $this->downloadFileAsyncWithHttpInfo($filepath, $filename, $redirect)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadFileAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $filepath Path of the file where it resides and with the name of the file to be downloaded. (required)
     * @param  string $filename Name of the file to be downloaded (required)
     * @param  string $redirect (Optional)Set it to 1 to directly download from Amazon S3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFileAsyncWithHttpInfo($filepath, $filename, $redirect = null)
    {
        $returnType = '';
        $request = $this->downloadFileRequest($filepath, $filename, $redirect);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadFile'
     *
     * @param  string $filepath Path of the file where it resides and with the name of the file to be downloaded. (required)
     * @param  string $filename Name of the file to be downloaded (required)
     * @param  string $redirect (Optional)Set it to 1 to directly download from Amazon S3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function downloadFileRequest($filepath, $filename, $redirect = null)
    {
        // verify the required parameter 'filepath' is set
        if ($filepath === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filepath when calling downloadFile'
            );
        }
        // verify the required parameter 'filename' is set
        if ($filename === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filename when calling downloadFile'
            );
        }

        $resourcePath = '/core/downloadfile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filepath !== null) {
            $queryParams['filepath'] = ObjectSerializer::toQueryValue($filepath);
        }
        // query params
        if ($filename !== null) {
            $queryParams['filename'] = ObjectSerializer::toQueryValue($filename);
        }
        // query params
        if ($redirect !== null) {
            $queryParams['redirect'] = ObjectSerializer::toQueryValue($redirect);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadFileMulti
     *
     * @param  float $count Number of files to be downloaded (required)
     * @param  string $filepath Path of the file where it resides. (required)
     * @param  string $fn1 First file name selected for download (required)
     * @param  string $fn2 Second file name selected for download {To downlaod more keep adding param&#39;s like fn3, fn4..} (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function downloadFileMulti($count, $filepath, $fn1, $fn2)
    {
        $this->downloadFileMultiWithHttpInfo($count, $filepath, $fn1, $fn2);
    }

    /**
     * Operation downloadFileMultiWithHttpInfo
     *
     * @param  float $count Number of files to be downloaded (required)
     * @param  string $filepath Path of the file where it resides. (required)
     * @param  string $fn1 First file name selected for download (required)
     * @param  string $fn2 Second file name selected for download {To downlaod more keep adding param&#39;s like fn3, fn4..} (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadFileMultiWithHttpInfo($count, $filepath, $fn1, $fn2)
    {
        $returnType = '';
        $request = $this->downloadFileMultiRequest($count, $filepath, $fn1, $fn2);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation downloadFileMultiAsync
     *
     * 
     *
     * @param  float $count Number of files to be downloaded (required)
     * @param  string $filepath Path of the file where it resides. (required)
     * @param  string $fn1 First file name selected for download (required)
     * @param  string $fn2 Second file name selected for download {To downlaod more keep adding param&#39;s like fn3, fn4..} (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFileMultiAsync($count, $filepath, $fn1, $fn2)
    {
        return $this->downloadFileMultiAsyncWithHttpInfo($count, $filepath, $fn1, $fn2)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadFileMultiAsyncWithHttpInfo
     *
     * 
     *
     * @param  float $count Number of files to be downloaded (required)
     * @param  string $filepath Path of the file where it resides. (required)
     * @param  string $fn1 First file name selected for download (required)
     * @param  string $fn2 Second file name selected for download {To downlaod more keep adding param&#39;s like fn3, fn4..} (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFileMultiAsyncWithHttpInfo($count, $filepath, $fn1, $fn2)
    {
        $returnType = '';
        $request = $this->downloadFileMultiRequest($count, $filepath, $fn1, $fn2);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadFileMulti'
     *
     * @param  float $count Number of files to be downloaded (required)
     * @param  string $filepath Path of the file where it resides. (required)
     * @param  string $fn1 First file name selected for download (required)
     * @param  string $fn2 Second file name selected for download {To downlaod more keep adding param&#39;s like fn3, fn4..} (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function downloadFileMultiRequest($count, $filepath, $fn1, $fn2)
    {
        // verify the required parameter 'count' is set
        if ($count === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling downloadFileMulti'
            );
        }
        // verify the required parameter 'filepath' is set
        if ($filepath === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filepath when calling downloadFileMulti'
            );
        }
        // verify the required parameter 'fn1' is set
        if ($fn1 === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fn1 when calling downloadFileMulti'
            );
        }
        // verify the required parameter 'fn2' is set
        if ($fn2 === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fn2 when calling downloadFileMulti'
            );
        }

        $resourcePath = '/core/downloadfilemulti';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count);
        }
        // query params
        if ($filepath !== null) {
            $queryParams['filepath'] = ObjectSerializer::toQueryValue($filepath);
        }
        // query params
        if ($fn1 !== null) {
            $queryParams['fn1'] = ObjectSerializer::toQueryValue($fn1);
        }
        // query params
        if ($fn2 !== null) {
            $queryParams['fn2'] = ObjectSerializer::toQueryValue($fn2);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation emptyRecycleBin
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function emptyRecycleBin()
    {
        list($response) = $this->emptyRecycleBinWithHttpInfo();
        return $response;
    }

    /**
     * Operation emptyRecycleBinWithHttpInfo
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function emptyRecycleBinWithHttpInfo()
    {
        $returnType = 'string';
        $request = $this->emptyRecycleBinRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation emptyRecycleBinAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function emptyRecycleBinAsync()
    {
        return $this->emptyRecycleBinAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation emptyRecycleBinAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function emptyRecycleBinAsyncWithHttpInfo()
    {
        $returnType = 'string';
        $request = $this->emptyRecycleBinRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'emptyRecycleBin'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function emptyRecycleBinRequest()
    {

        $resourcePath = '/core/emptyrecyclebin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fileExists
     *
     * @param  string $file Path of the file where it resides (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function fileExists($file)
    {
        list($response) = $this->fileExistsWithHttpInfo($file);
        return $response;
    }

    /**
     * Operation fileExistsWithHttpInfo
     *
     * @param  string $file Path of the file where it resides (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function fileExistsWithHttpInfo($file)
    {
        $returnType = 'string';
        $request = $this->fileExistsRequest($file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fileExistsAsync
     *
     * 
     *
     * @param  string $file Path of the file where it resides (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fileExistsAsync($file)
    {
        return $this->fileExistsAsyncWithHttpInfo($file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fileExistsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $file Path of the file where it resides (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fileExistsAsyncWithHttpInfo($file)
    {
        $returnType = 'string';
        $request = $this->fileExistsRequest($file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fileExists'
     *
     * @param  string $file Path of the file where it resides (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function fileExistsRequest($file)
    {
        // verify the required parameter 'file' is set
        if ($file === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling fileExists'
            );
        }

        $resourcePath = '/core/fileexists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($file !== null) {
            $formParams['file'] = ObjectSerializer::toFormValue($file);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fileInfo
     *
     * @param  string $file Path of file to be specified (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function fileInfo($file)
    {
        list($response) = $this->fileInfoWithHttpInfo($file);
        return $response;
    }

    /**
     * Operation fileInfoWithHttpInfo
     *
     * @param  string $file Path of file to be specified (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function fileInfoWithHttpInfo($file)
    {
        $returnType = 'string';
        $request = $this->fileInfoRequest($file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fileInfoAsync
     *
     * 
     *
     * @param  string $file Path of file to be specified (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fileInfoAsync($file)
    {
        return $this->fileInfoAsyncWithHttpInfo($file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fileInfoAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $file Path of file to be specified (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fileInfoAsyncWithHttpInfo($file)
    {
        $returnType = 'string';
        $request = $this->fileInfoRequest($file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fileInfo'
     *
     * @param  string $file Path of file to be specified (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function fileInfoRequest($file)
    {
        // verify the required parameter 'file' is set
        if ($file === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling fileInfo'
            );
        }

        $resourcePath = '/core/fileinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($file !== null) {
            $formParams['file'] = ObjectSerializer::toFormValue($file);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccessDetailsForPath
     *
     * @param  string $fullpath Path of the file/folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getAccessDetailsForPath($fullpath)
    {
        list($response) = $this->getAccessDetailsForPathWithHttpInfo($fullpath);
        return $response;
    }

    /**
     * Operation getAccessDetailsForPathWithHttpInfo
     *
     * @param  string $fullpath Path of the file/folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccessDetailsForPathWithHttpInfo($fullpath)
    {
        $returnType = 'string';
        $request = $this->getAccessDetailsForPathRequest($fullpath);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccessDetailsForPathAsync
     *
     * 
     *
     * @param  string $fullpath Path of the file/folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccessDetailsForPathAsync($fullpath)
    {
        return $this->getAccessDetailsForPathAsyncWithHttpInfo($fullpath)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccessDetailsForPathAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $fullpath Path of the file/folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccessDetailsForPathAsyncWithHttpInfo($fullpath)
    {
        $returnType = 'string';
        $request = $this->getAccessDetailsForPathRequest($fullpath);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccessDetailsForPath'
     *
     * @param  string $fullpath Path of the file/folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccessDetailsForPathRequest($fullpath)
    {
        // verify the required parameter 'fullpath' is set
        if ($fullpath === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fullpath when calling getAccessDetailsForPath'
            );
        }

        $resourcePath = '/core/getaccessdetailsforpath';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fullpath !== null) {
            $queryParams['fullpath'] = ObjectSerializer::toQueryValue($fullpath);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileList
     *
     * @param  string $path Path Name to be specified, If the user wants to access MyFiles then use the username as path. (required)
     * @param  string $sortdir Set it to 1 for ascending sort , -1 for descending sort (required)
     * @param  string $sortby You can sort by name, date or size. (required)
     * @param  string $start Start index of records to retrieve, Note: Index starts from 0. Default 0 (required)
     * @param  string $limit Set to any number of record you want to view at once. Default 10 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getFileList($path, $sortdir, $sortby, $start, $limit)
    {
        list($response) = $this->getFileListWithHttpInfo($path, $sortdir, $sortby, $start, $limit);
        return $response;
    }

    /**
     * Operation getFileListWithHttpInfo
     *
     * @param  string $path Path Name to be specified, If the user wants to access MyFiles then use the username as path. (required)
     * @param  string $sortdir Set it to 1 for ascending sort , -1 for descending sort (required)
     * @param  string $sortby You can sort by name, date or size. (required)
     * @param  string $start Start index of records to retrieve, Note: Index starts from 0. Default 0 (required)
     * @param  string $limit Set to any number of record you want to view at once. Default 10 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileListWithHttpInfo($path, $sortdir, $sortby, $start, $limit)
    {
        $returnType = 'string';
        $request = $this->getFileListRequest($path, $sortdir, $sortby, $start, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFileListAsync
     *
     * 
     *
     * @param  string $path Path Name to be specified, If the user wants to access MyFiles then use the username as path. (required)
     * @param  string $sortdir Set it to 1 for ascending sort , -1 for descending sort (required)
     * @param  string $sortby You can sort by name, date or size. (required)
     * @param  string $start Start index of records to retrieve, Note: Index starts from 0. Default 0 (required)
     * @param  string $limit Set to any number of record you want to view at once. Default 10 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileListAsync($path, $sortdir, $sortby, $start, $limit)
    {
        return $this->getFileListAsyncWithHttpInfo($path, $sortdir, $sortby, $start, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path Path Name to be specified, If the user wants to access MyFiles then use the username as path. (required)
     * @param  string $sortdir Set it to 1 for ascending sort , -1 for descending sort (required)
     * @param  string $sortby You can sort by name, date or size. (required)
     * @param  string $start Start index of records to retrieve, Note: Index starts from 0. Default 0 (required)
     * @param  string $limit Set to any number of record you want to view at once. Default 10 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileListAsyncWithHttpInfo($path, $sortdir, $sortby, $start, $limit)
    {
        $returnType = 'string';
        $request = $this->getFileListRequest($path, $sortdir, $sortby, $start, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileList'
     *
     * @param  string $path Path Name to be specified, If the user wants to access MyFiles then use the username as path. (required)
     * @param  string $sortdir Set it to 1 for ascending sort , -1 for descending sort (required)
     * @param  string $sortby You can sort by name, date or size. (required)
     * @param  string $start Start index of records to retrieve, Note: Index starts from 0. Default 0 (required)
     * @param  string $limit Set to any number of record you want to view at once. Default 10 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFileListRequest($path, $sortdir, $sortby, $start, $limit)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getFileList'
            );
        }
        // verify the required parameter 'sortdir' is set
        if ($sortdir === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sortdir when calling getFileList'
            );
        }
        // verify the required parameter 'sortby' is set
        if ($sortby === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sortby when calling getFileList'
            );
        }
        // verify the required parameter 'start' is set
        if ($start === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start when calling getFileList'
            );
        }
        // verify the required parameter 'limit' is set
        if ($limit === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling getFileList'
            );
        }

        $resourcePath = '/core/getfilelist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($sortdir !== null) {
            $queryParams['sortdir'] = ObjectSerializer::toQueryValue($sortdir);
        }
        // query params
        if ($sortby !== null) {
            $queryParams['sortby'] = ObjectSerializer::toQueryValue($sortby);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFolderProperties
     *
     * @param  string $path Path of the folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getFolderProperties($path)
    {
        list($response) = $this->getFolderPropertiesWithHttpInfo($path);
        return $response;
    }

    /**
     * Operation getFolderPropertiesWithHttpInfo
     *
     * @param  string $path Path of the folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFolderPropertiesWithHttpInfo($path)
    {
        $returnType = 'string';
        $request = $this->getFolderPropertiesRequest($path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFolderPropertiesAsync
     *
     * 
     *
     * @param  string $path Path of the folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderPropertiesAsync($path)
    {
        return $this->getFolderPropertiesAsyncWithHttpInfo($path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFolderPropertiesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path Path of the folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderPropertiesAsyncWithHttpInfo($path)
    {
        $returnType = 'string';
        $request = $this->getFolderPropertiesRequest($path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFolderProperties'
     *
     * @param  string $path Path of the folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFolderPropertiesRequest($path)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getFolderProperties'
            );
        }

        $resourcePath = '/core/getfolderproperties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWOpIEditUrl
     *
     * @param  string $op Specify the operation name (required)
     * @param  string $path Specify the location of file (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getWOpIEditUrl($op, $path)
    {
        $this->getWOpIEditUrlWithHttpInfo($op, $path);
    }

    /**
     * Operation getWOpIEditUrlWithHttpInfo
     *
     * @param  string $op Specify the operation name (required)
     * @param  string $path Specify the location of file (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWOpIEditUrlWithHttpInfo($op, $path)
    {
        $returnType = '';
        $request = $this->getWOpIEditUrlRequest($op, $path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getWOpIEditUrlAsync
     *
     * 
     *
     * @param  string $op Specify the operation name (required)
     * @param  string $path Specify the location of file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWOpIEditUrlAsync($op, $path)
    {
        return $this->getWOpIEditUrlAsyncWithHttpInfo($op, $path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWOpIEditUrlAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $op Specify the operation name (required)
     * @param  string $path Specify the location of file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWOpIEditUrlAsyncWithHttpInfo($op, $path)
    {
        $returnType = '';
        $request = $this->getWOpIEditUrlRequest($op, $path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWOpIEditUrl'
     *
     * @param  string $op Specify the operation name (required)
     * @param  string $path Specify the location of file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWOpIEditUrlRequest($op, $path)
    {
        // verify the required parameter 'op' is set
        if ($op === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $op when calling getWOpIEditUrl'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getWOpIEditUrl'
            );
        }

        $resourcePath = '/core/getwopiediturl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($op !== null) {
            $queryParams['op'] = ObjectSerializer::toQueryValue($op);
        }
        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation renameFile
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be renamed. (required)
     * @param  string $newname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function renameFile($path, $name, $newname)
    {
        list($response) = $this->renameFileWithHttpInfo($path, $name, $newname);
        return $response;
    }

    /**
     * Operation renameFileWithHttpInfo
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be renamed. (required)
     * @param  string $newname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function renameFileWithHttpInfo($path, $name, $newname)
    {
        $returnType = 'string';
        $request = $this->renameFileRequest($path, $name, $newname);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation renameFileAsync
     *
     * 
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be renamed. (required)
     * @param  string $newname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renameFileAsync($path, $name, $newname)
    {
        return $this->renameFileAsyncWithHttpInfo($path, $name, $newname)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation renameFileAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be renamed. (required)
     * @param  string $newname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renameFileAsyncWithHttpInfo($path, $name, $newname)
    {
        $returnType = 'string';
        $request = $this->renameFileRequest($path, $name, $newname);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'renameFile'
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be renamed. (required)
     * @param  string $newname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function renameFileRequest($path, $name, $newname)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling renameFile'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling renameFile'
            );
        }
        // verify the required parameter 'newname' is set
        if ($newname === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $newname when calling renameFile'
            );
        }

        $resourcePath = '/core/renamefile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($newname !== null) {
            $formParams['newname'] = ObjectSerializer::toFormValue($newname);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation renameOrMove
     *
     * @param  string $fromname Name of the file with the path where the file resides. (required)
     * @param  string $toname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function renameOrMove($fromname, $toname)
    {
        list($response) = $this->renameOrMoveWithHttpInfo($fromname, $toname);
        return $response;
    }

    /**
     * Operation renameOrMoveWithHttpInfo
     *
     * @param  string $fromname Name of the file with the path where the file resides. (required)
     * @param  string $toname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function renameOrMoveWithHttpInfo($fromname, $toname)
    {
        $returnType = 'string';
        $request = $this->renameOrMoveRequest($fromname, $toname);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation renameOrMoveAsync
     *
     * 
     *
     * @param  string $fromname Name of the file with the path where the file resides. (required)
     * @param  string $toname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renameOrMoveAsync($fromname, $toname)
    {
        return $this->renameOrMoveAsyncWithHttpInfo($fromname, $toname)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation renameOrMoveAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $fromname Name of the file with the path where the file resides. (required)
     * @param  string $toname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renameOrMoveAsyncWithHttpInfo($fromname, $toname)
    {
        $returnType = 'string';
        $request = $this->renameOrMoveRequest($fromname, $toname);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'renameOrMove'
     *
     * @param  string $fromname Name of the file with the path where the file resides. (required)
     * @param  string $toname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function renameOrMoveRequest($fromname, $toname)
    {
        // verify the required parameter 'fromname' is set
        if ($fromname === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fromname when calling renameOrMove'
            );
        }
        // verify the required parameter 'toname' is set
        if ($toname === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $toname when calling renameOrMove'
            );
        }

        $resourcePath = '/core/renameormove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($fromname !== null) {
            $formParams['fromname'] = ObjectSerializer::toFormValue($fromname);
        }
        // form params
        if ($toname !== null) {
            $formParams['toname'] = ObjectSerializer::toFormValue($toname);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation search
     *
     * @param  string $keyword Keyword to search (required)
     * @param  string $location Specify the directory path in which you want to perform search. (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function search($keyword, $location, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        list($response) = $this->searchWithHttpInfo($keyword, $location, $minsize, $maxsize, $modifiedstart, $modifiedend);
        return $response;
    }

    /**
     * Operation searchWithHttpInfo
     *
     * @param  string $keyword Keyword to search (required)
     * @param  string $location Specify the directory path in which you want to perform search. (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchWithHttpInfo($keyword, $location, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        $returnType = 'string';
        $request = $this->searchRequest($keyword, $location, $minsize, $maxsize, $modifiedstart, $modifiedend);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchAsync
     *
     * 
     *
     * @param  string $keyword Keyword to search (required)
     * @param  string $location Specify the directory path in which you want to perform search. (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsync($keyword, $location, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        return $this->searchAsyncWithHttpInfo($keyword, $location, $minsize, $maxsize, $modifiedstart, $modifiedend)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $keyword Keyword to search (required)
     * @param  string $location Specify the directory path in which you want to perform search. (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsyncWithHttpInfo($keyword, $location, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        $returnType = 'string';
        $request = $this->searchRequest($keyword, $location, $minsize, $maxsize, $modifiedstart, $modifiedend);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'search'
     *
     * @param  string $keyword Keyword to search (required)
     * @param  string $location Specify the directory path in which you want to perform search. (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRequest($keyword, $location, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        // verify the required parameter 'keyword' is set
        if ($keyword === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $keyword when calling search'
            );
        }
        // verify the required parameter 'location' is set
        if ($location === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location when calling search'
            );
        }

        $resourcePath = '/core/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($keyword !== null) {
            $formParams['keyword'] = ObjectSerializer::toFormValue($keyword);
        }
        // form params
        if ($location !== null) {
            $formParams['location'] = ObjectSerializer::toFormValue($location);
        }
        // form params
        if ($minsize !== null) {
            $formParams['minsize'] = ObjectSerializer::toFormValue($minsize);
        }
        // form params
        if ($maxsize !== null) {
            $formParams['maxsize'] = ObjectSerializer::toFormValue($maxsize);
        }
        // form params
        if ($modifiedstart !== null) {
            $formParams['modifiedstart'] = ObjectSerializer::toFormValue($modifiedstart);
        }
        // form params
        if ($modifiedend !== null) {
            $formParams['modifiedend'] = ObjectSerializer::toFormValue($modifiedend);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchExt
     *
     * @param  string $op Operantion name - searchcontent (required)
     * @param  string $searchname Specify the filename to be searched. (required)
     * @param  string $searchtext Specify the text to search (required)
     * @param  string $searchloc (optional) Specify the directory path in which you want to perform search (if not specified user&#39;s home directory will be the path) (optional)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function searchExt($op, $searchname, $searchtext, $searchloc = null, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        list($response) = $this->searchExtWithHttpInfo($op, $searchname, $searchtext, $searchloc, $minsize, $maxsize, $modifiedstart, $modifiedend);
        return $response;
    }

    /**
     * Operation searchExtWithHttpInfo
     *
     * @param  string $op Operantion name - searchcontent (required)
     * @param  string $searchname Specify the filename to be searched. (required)
     * @param  string $searchtext Specify the text to search (required)
     * @param  string $searchloc (optional) Specify the directory path in which you want to perform search (if not specified user&#39;s home directory will be the path) (optional)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchExtWithHttpInfo($op, $searchname, $searchtext, $searchloc = null, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        $returnType = 'string';
        $request = $this->searchExtRequest($op, $searchname, $searchtext, $searchloc, $minsize, $maxsize, $modifiedstart, $modifiedend);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchExtAsync
     *
     * 
     *
     * @param  string $op Operantion name - searchcontent (required)
     * @param  string $searchname Specify the filename to be searched. (required)
     * @param  string $searchtext Specify the text to search (required)
     * @param  string $searchloc (optional) Specify the directory path in which you want to perform search (if not specified user&#39;s home directory will be the path) (optional)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchExtAsync($op, $searchname, $searchtext, $searchloc = null, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        return $this->searchExtAsyncWithHttpInfo($op, $searchname, $searchtext, $searchloc, $minsize, $maxsize, $modifiedstart, $modifiedend)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchExtAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $op Operantion name - searchcontent (required)
     * @param  string $searchname Specify the filename to be searched. (required)
     * @param  string $searchtext Specify the text to search (required)
     * @param  string $searchloc (optional) Specify the directory path in which you want to perform search (if not specified user&#39;s home directory will be the path) (optional)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchExtAsyncWithHttpInfo($op, $searchname, $searchtext, $searchloc = null, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        $returnType = 'string';
        $request = $this->searchExtRequest($op, $searchname, $searchtext, $searchloc, $minsize, $maxsize, $modifiedstart, $modifiedend);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchExt'
     *
     * @param  string $op Operantion name - searchcontent (required)
     * @param  string $searchname Specify the filename to be searched. (required)
     * @param  string $searchtext Specify the text to search (required)
     * @param  string $searchloc (optional) Specify the directory path in which you want to perform search (if not specified user&#39;s home directory will be the path) (optional)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param  string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchExtRequest($op, $searchname, $searchtext, $searchloc = null, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        // verify the required parameter 'op' is set
        if ($op === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $op when calling searchExt'
            );
        }
        // verify the required parameter 'searchname' is set
        if ($searchname === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchname when calling searchExt'
            );
        }
        // verify the required parameter 'searchtext' is set
        if ($searchtext === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchtext when calling searchExt'
            );
        }

        $resourcePath = '/app/searchext/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($op !== null) {
            $formParams['op'] = ObjectSerializer::toFormValue($op);
        }
        // form params
        if ($searchname !== null) {
            $formParams['searchname'] = ObjectSerializer::toFormValue($searchname);
        }
        // form params
        if ($searchtext !== null) {
            $formParams['searchtext'] = ObjectSerializer::toFormValue($searchtext);
        }
        // form params
        if ($searchloc !== null) {
            $formParams['searchloc'] = ObjectSerializer::toFormValue($searchloc);
        }
        // form params
        if ($minsize !== null) {
            $formParams['minsize'] = ObjectSerializer::toFormValue($minsize);
        }
        // form params
        if ($maxsize !== null) {
            $formParams['maxsize'] = ObjectSerializer::toFormValue($maxsize);
        }
        // form params
        if ($modifiedstart !== null) {
            $formParams['modifiedstart'] = ObjectSerializer::toFormValue($modifiedstart);
        }
        // form params
        if ($modifiedend !== null) {
            $formParams['modifiedend'] = ObjectSerializer::toFormValue($modifiedend);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchTermSearch
     *
     * @param  string $searchterm Specify the search term (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function searchTermSearch($searchterm)
    {
        list($response) = $this->searchTermSearchWithHttpInfo($searchterm);
        return $response;
    }

    /**
     * Operation searchTermSearchWithHttpInfo
     *
     * @param  string $searchterm Specify the search term (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchTermSearchWithHttpInfo($searchterm)
    {
        $returnType = 'string';
        $request = $this->searchTermSearchRequest($searchterm);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchTermSearchAsync
     *
     * 
     *
     * @param  string $searchterm Specify the search term (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchTermSearchAsync($searchterm)
    {
        return $this->searchTermSearchAsyncWithHttpInfo($searchterm)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchTermSearchAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $searchterm Specify the search term (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchTermSearchAsyncWithHttpInfo($searchterm)
    {
        $returnType = 'string';
        $request = $this->searchTermSearchRequest($searchterm);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchTermSearch'
     *
     * @param  string $searchterm Specify the search term (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchTermSearchRequest($searchterm)
    {
        // verify the required parameter 'searchterm' is set
        if ($searchterm === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchterm when calling searchTermSearch'
            );
        }

        $resourcePath = '/core/searchtermsearch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($searchterm !== null) {
            $formParams['searchterm'] = ObjectSerializer::toFormValue($searchterm);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation upload
     *
     * @param  string $appname Agent use to upload files to system (required)
     * @param  string $path Specify the path where you want to upload the file (required)
     * @param  float $offset Offset set to 0 (required)
     * @param  float $complete Complete set to 1 (required)
     * @param  string $filename File name to be uploaded inside the folder (required)
     * @param  \SplFileObject $file_contents The path to the file you want to upload. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function upload($appname, $path, $offset, $complete, $filename, $file_contents)
    {
        $this->uploadWithHttpInfo($appname, $path, $offset, $complete, $filename, $file_contents);
    }

    /**
     * Operation uploadWithHttpInfo
     *
     * @param  string $appname Agent use to upload files to system (required)
     * @param  string $path Specify the path where you want to upload the file (required)
     * @param  float $offset Offset set to 0 (required)
     * @param  float $complete Complete set to 1 (required)
     * @param  string $filename File name to be uploaded inside the folder (required)
     * @param  \SplFileObject $file_contents The path to the file you want to upload. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadWithHttpInfo($appname, $path, $offset, $complete, $filename, $file_contents)
    {
        $returnType = '';
        $request = $this->uploadRequest($appname, $path, $offset, $complete, $filename, $file_contents);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation uploadAsync
     *
     * 
     *
     * @param  string $appname Agent use to upload files to system (required)
     * @param  string $path Specify the path where you want to upload the file (required)
     * @param  float $offset Offset set to 0 (required)
     * @param  float $complete Complete set to 1 (required)
     * @param  string $filename File name to be uploaded inside the folder (required)
     * @param  \SplFileObject $file_contents The path to the file you want to upload. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAsync($appname, $path, $offset, $complete, $filename, $file_contents)
    {
        return $this->uploadAsyncWithHttpInfo($appname, $path, $offset, $complete, $filename, $file_contents)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $appname Agent use to upload files to system (required)
     * @param  string $path Specify the path where you want to upload the file (required)
     * @param  float $offset Offset set to 0 (required)
     * @param  float $complete Complete set to 1 (required)
     * @param  string $filename File name to be uploaded inside the folder (required)
     * @param  \SplFileObject $file_contents The path to the file you want to upload. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAsyncWithHttpInfo($appname, $path, $offset, $complete, $filename, $file_contents)
    {
        $returnType = '';
        $request = $this->uploadRequest($appname, $path, $offset, $complete, $filename, $file_contents);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'upload'
     *
     * @param  string $appname Agent use to upload files to system (required)
     * @param  string $path Specify the path where you want to upload the file (required)
     * @param  float $offset Offset set to 0 (required)
     * @param  float $complete Complete set to 1 (required)
     * @param  string $filename File name to be uploaded inside the folder (required)
     * @param  \SplFileObject $file_contents The path to the file you want to upload. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadRequest($appname, $path, $offset, $complete, $filename, $file_contents)
    {
        // verify the required parameter 'appname' is set
        if ($appname === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $appname when calling upload'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling upload'
            );
        }
        // verify the required parameter 'offset' is set
        if ($offset === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling upload'
            );
        }
        // verify the required parameter 'complete' is set
        if ($complete === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $complete when calling upload'
            );
        }
        // verify the required parameter 'filename' is set
        if ($filename === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filename when calling upload'
            );
        }
        // verify the required parameter 'file_contents' is set
        if ($file_contents === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_contents when calling upload'
            );
        }

        $resourcePath = '/core/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($appname !== null) {
            $queryParams['appname'] = ObjectSerializer::toQueryValue($appname);
        }
        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($complete !== null) {
            $queryParams['complete'] = ObjectSerializer::toQueryValue($complete);
        }
        // query params
        if ($filename !== null) {
            $queryParams['filename'] = ObjectSerializer::toQueryValue($filename);
        }


        // form params
        if ($file_contents !== null) {
            $multipart = true;
            $formParams['file_contents'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file_contents), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
