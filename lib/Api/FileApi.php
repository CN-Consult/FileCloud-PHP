<?php
/**
 * FileApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache License v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * FileCloud API
 *
 * The FileCloud APIs provide developers with the tools necessary to build a variety of apps and clients. This allows extensibility and integration of FileCloud with your existing enterprise systems and frameworks. FileCloud developer API is simple to use and integrate.
 *
 * OpenAPI spec version: 14.0.0.34184
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use \Swagger\Client\ApiClient;
use \Swagger\Client\ApiException;
use \Swagger\Client\Configuration;
use \Swagger\Client\ObjectSerializer;

/**
 * FileApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache License v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class FileApi
{
    /**
     * API Client
     *
     * @var \Swagger\Client\ApiClient instance of the ApiClient
     */
    protected $apiClient;

    /**
     * Constructor
     *
     * @param \Swagger\Client\ApiClient|null $apiClient The api client to use
     */
    public function __construct(\Swagger\Client\ApiClient $apiClient = null)
    {
        if ($apiClient === null) {
            $apiClient = new ApiClient();
            $apiClient->getConfig()->setHost('https://localhost');
        }

        $this->apiClient = $apiClient;
    }

    /**
     * Get API client
     *
     * @return \Swagger\Client\ApiClient get the API client
     */
    public function getApiClient()
    {
        return $this->apiClient;
    }

    /**
     * Set the API client
     *
     * @param \Swagger\Client\ApiClient $apiClient set the API client
     *
     * @return FileApi
     */
    public function setApiClient(\Swagger\Client\ApiClient $apiClient)
    {
        $this->apiClient = $apiClient;
        return $this;
    }

    /**
     * Operation copyFile
     *
     * 
     *
     * @param string $copyto Path where the files has to be copied (required)
     * @param string $path Path where the files reside (required)
     * @param string $name Name of the image file, eg: /Path/Image file name. (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function copyFile($copyto, $path, $name)
    {
        list($response) = $this->copyFileWithHttpInfo($copyto, $path, $name);
        return $response;
    }

    /**
     * Operation copyFileWithHttpInfo
     *
     * 
     *
     * @param string $copyto Path where the files has to be copied (required)
     * @param string $path Path where the files reside (required)
     * @param string $name Name of the image file, eg: /Path/Image file name. (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyFileWithHttpInfo($copyto, $path, $name)
    {
        // verify the required parameter 'copyto' is set
        if ($copyto === null) {
            throw new \InvalidArgumentException('Missing the required parameter $copyto when calling copyFile');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling copyFile');
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling copyFile');
        }
        // parse inputs
        $resourcePath = "/core/copyfile";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/x-www-form-urlencoded']);

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($copyto !== null) {
            $formParams['copyto'] = $this->apiClient->getSerializer()->toFormValue($copyto);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = $this->apiClient->getSerializer()->toFormValue($path);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = $this->apiClient->getSerializer()->toFormValue($name);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/core/copyfile'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation createFolder
     *
     * 
     *
     * @param string $name Name of the folder to be created (required)
     * @param string $path Path where you want to create the folder (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function createFolder($name, $path)
    {
        list($response) = $this->createFolderWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation createFolderWithHttpInfo
     *
     * 
     *
     * @param string $name Name of the folder to be created (required)
     * @param string $path Path where you want to create the folder (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFolderWithHttpInfo($name, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling createFolder');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling createFolder');
        }
        // parse inputs
        $resourcePath = "/app/explorer/createfolder";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/x-www-form-urlencoded']);

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($name !== null) {
            $formParams['name'] = $this->apiClient->getSerializer()->toFormValue($name);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = $this->apiClient->getSerializer()->toFormValue($path);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/app/explorer/createfolder'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteFile
     *
     * 
     *
     * @param string $path Path of the file where it resides. (required)
     * @param string $name Name of the file to be deleted. (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function deleteFile($path, $name)
    {
        list($response) = $this->deleteFileWithHttpInfo($path, $name);
        return $response;
    }

    /**
     * Operation deleteFileWithHttpInfo
     *
     * 
     *
     * @param string $path Path of the file where it resides. (required)
     * @param string $name Name of the file to be deleted. (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFileWithHttpInfo($path, $name)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling deleteFile');
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling deleteFile');
        }
        // parse inputs
        $resourcePath = "/core/deletefile";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/x-www-form-urlencoded']);

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($path !== null) {
            $formParams['path'] = $this->apiClient->getSerializer()->toFormValue($path);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = $this->apiClient->getSerializer()->toFormValue($name);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/core/deletefile'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deletePartialUploads
     *
     * 
     *
     * @param int $ignorets Set value to 1 to delete partial uploads using API call (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function deletePartialUploads($ignorets)
    {
        list($response) = $this->deletePartialUploadsWithHttpInfo($ignorets);
        return $response;
    }

    /**
     * Operation deletePartialUploadsWithHttpInfo
     *
     * 
     *
     * @param int $ignorets Set value to 1 to delete partial uploads using API call (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePartialUploadsWithHttpInfo($ignorets)
    {
        // verify the required parameter 'ignorets' is set
        if ($ignorets === null) {
            throw new \InvalidArgumentException('Missing the required parameter $ignorets when calling deletePartialUploads');
        }
        // parse inputs
        $resourcePath = "/core/deletepartialuploads";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/x-www-form-urlencoded']);

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($ignorets !== null) {
            $formParams['ignorets'] = $this->apiClient->getSerializer()->toFormValue($ignorets);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/core/deletepartialuploads'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation docEdit
     *
     * 
     *
     * @param string $path Path of the file where it resides (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return void
     */
    public function docEdit($path)
    {
        list($response) = $this->docEditWithHttpInfo($path);
        return $response;
    }

    /**
     * Operation docEditWithHttpInfo
     *
     * 
     *
     * @param string $path Path of the file where it resides (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function docEditWithHttpInfo($path)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling docEdit');
        }
        // parse inputs
        $resourcePath = "/core/docedit";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/x-www-form-urlencoded']);

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($path !== null) {
            $formParams['path'] = $this->apiClient->getSerializer()->toFormValue($path);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/core/docedit'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation downloadFile
     *
     * 
     *
     * @param string $filepath Path of the file where it resides and with the name of the file to be downloaded. (required)
     * @param string $filename Name of the file to be downloaded (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return void
     */
    public function downloadFile($filepath, $filename)
    {
        list($response) = $this->downloadFileWithHttpInfo($filepath, $filename);
        return $response;
    }

    /**
     * Operation downloadFileWithHttpInfo
     *
     * 
     *
     * @param string $filepath Path of the file where it resides and with the name of the file to be downloaded. (required)
     * @param string $filename Name of the file to be downloaded (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadFileWithHttpInfo($filepath, $filename)
    {
        // verify the required parameter 'filepath' is set
        if ($filepath === null) {
            throw new \InvalidArgumentException('Missing the required parameter $filepath when calling downloadFile');
        }
        // verify the required parameter 'filename' is set
        if ($filename === null) {
            throw new \InvalidArgumentException('Missing the required parameter $filename when calling downloadFile');
        }
        // parse inputs
        $resourcePath = "/core/downloadfile";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($filepath !== null) {
            $queryParams['filepath'] = $this->apiClient->getSerializer()->toQueryValue($filepath);
        }
        // query params
        if ($filename !== null) {
            $queryParams['filename'] = $this->apiClient->getSerializer()->toQueryValue($filename);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/core/downloadfile'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation downloadFileMulti
     *
     * 
     *
     * @param float $count Number of files to be downloaded (required)
     * @param string $filepath Path of the file where it resides. (required)
     * @param string $fn1 First file name selected for download (required)
     * @param string $fn2 Second file name selected for download {To downlaod more keep adding param&#39;s like fn3, fn4..} (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return void
     */
    public function downloadFileMulti($count, $filepath, $fn1, $fn2)
    {
        list($response) = $this->downloadFileMultiWithHttpInfo($count, $filepath, $fn1, $fn2);
        return $response;
    }

    /**
     * Operation downloadFileMultiWithHttpInfo
     *
     * 
     *
     * @param float $count Number of files to be downloaded (required)
     * @param string $filepath Path of the file where it resides. (required)
     * @param string $fn1 First file name selected for download (required)
     * @param string $fn2 Second file name selected for download {To downlaod more keep adding param&#39;s like fn3, fn4..} (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadFileMultiWithHttpInfo($count, $filepath, $fn1, $fn2)
    {
        // verify the required parameter 'count' is set
        if ($count === null) {
            throw new \InvalidArgumentException('Missing the required parameter $count when calling downloadFileMulti');
        }
        // verify the required parameter 'filepath' is set
        if ($filepath === null) {
            throw new \InvalidArgumentException('Missing the required parameter $filepath when calling downloadFileMulti');
        }
        // verify the required parameter 'fn1' is set
        if ($fn1 === null) {
            throw new \InvalidArgumentException('Missing the required parameter $fn1 when calling downloadFileMulti');
        }
        // verify the required parameter 'fn2' is set
        if ($fn2 === null) {
            throw new \InvalidArgumentException('Missing the required parameter $fn2 when calling downloadFileMulti');
        }
        // parse inputs
        $resourcePath = "/core/downloadfilemulti";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($count !== null) {
            $queryParams['count'] = $this->apiClient->getSerializer()->toQueryValue($count);
        }
        // query params
        if ($filepath !== null) {
            $queryParams['filepath'] = $this->apiClient->getSerializer()->toQueryValue($filepath);
        }
        // query params
        if ($fn1 !== null) {
            $queryParams['fn1'] = $this->apiClient->getSerializer()->toQueryValue($fn1);
        }
        // query params
        if ($fn2 !== null) {
            $queryParams['fn2'] = $this->apiClient->getSerializer()->toQueryValue($fn2);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/core/downloadfilemulti'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation emptyRecycleBin
     *
     * 
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function emptyRecycleBin()
    {
        list($response) = $this->emptyRecycleBinWithHttpInfo();
        return $response;
    }

    /**
     * Operation emptyRecycleBinWithHttpInfo
     *
     * 
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function emptyRecycleBinWithHttpInfo()
    {
        // parse inputs
        $resourcePath = "/core/emptyrecyclebin";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/core/emptyrecyclebin'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation fileExists
     *
     * 
     *
     * @param string $file Path of the file where it resides (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function fileExists($file)
    {
        list($response) = $this->fileExistsWithHttpInfo($file);
        return $response;
    }

    /**
     * Operation fileExistsWithHttpInfo
     *
     * 
     *
     * @param string $file Path of the file where it resides (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function fileExistsWithHttpInfo($file)
    {
        // verify the required parameter 'file' is set
        if ($file === null) {
            throw new \InvalidArgumentException('Missing the required parameter $file when calling fileExists');
        }
        // parse inputs
        $resourcePath = "/core/fileexists";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/x-www-form-urlencoded']);

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($file !== null) {
            $formParams['file'] = $this->apiClient->getSerializer()->toFormValue($file);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/core/fileexists'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation fileInfo
     *
     * 
     *
     * @param string $path Path of file to be specified (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function fileInfo($path)
    {
        list($response) = $this->fileInfoWithHttpInfo($path);
        return $response;
    }

    /**
     * Operation fileInfoWithHttpInfo
     *
     * 
     *
     * @param string $path Path of file to be specified (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function fileInfoWithHttpInfo($path)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling fileInfo');
        }
        // parse inputs
        $resourcePath = "/core/fileinfo";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/x-www-form-urlencoded']);

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($path !== null) {
            $formParams['path'] = $this->apiClient->getSerializer()->toFormValue($path);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/core/fileinfo'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getAccessDetailsForPath
     *
     * 
     *
     * @param string $fullpath Path of the file/folder (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getAccessDetailsForPath($fullpath)
    {
        list($response) = $this->getAccessDetailsForPathWithHttpInfo($fullpath);
        return $response;
    }

    /**
     * Operation getAccessDetailsForPathWithHttpInfo
     *
     * 
     *
     * @param string $fullpath Path of the file/folder (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccessDetailsForPathWithHttpInfo($fullpath)
    {
        // verify the required parameter 'fullpath' is set
        if ($fullpath === null) {
            throw new \InvalidArgumentException('Missing the required parameter $fullpath when calling getAccessDetailsForPath');
        }
        // parse inputs
        $resourcePath = "/core/getaccessdetailsforpath";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($fullpath !== null) {
            $queryParams['fullpath'] = $this->apiClient->getSerializer()->toQueryValue($fullpath);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/core/getaccessdetailsforpath'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getFileList
     *
     * 
     *
     * @param string $path Path Name to be specified, If the user wants to access MyFiles then use the username as path. (required)
     * @param string $sortdir Set it to 1 for ascending sort , -1 for descending sort (required)
     * @param string $sortby You can sort by name, date or size. (required)
     * @param string $start Start index of records to retrieve, Note: Index starts from 0. Default 0 (required)
     * @param string $limit Set to any number of record you want to view at once. Default 10 (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getFileList($path, $sortdir, $sortby, $start, $limit)
    {
        list($response) = $this->getFileListWithHttpInfo($path, $sortdir, $sortby, $start, $limit);
        return $response;
    }

    /**
     * Operation getFileListWithHttpInfo
     *
     * 
     *
     * @param string $path Path Name to be specified, If the user wants to access MyFiles then use the username as path. (required)
     * @param string $sortdir Set it to 1 for ascending sort , -1 for descending sort (required)
     * @param string $sortby You can sort by name, date or size. (required)
     * @param string $start Start index of records to retrieve, Note: Index starts from 0. Default 0 (required)
     * @param string $limit Set to any number of record you want to view at once. Default 10 (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileListWithHttpInfo($path, $sortdir, $sortby, $start, $limit)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling getFileList');
        }
        // verify the required parameter 'sortdir' is set
        if ($sortdir === null) {
            throw new \InvalidArgumentException('Missing the required parameter $sortdir when calling getFileList');
        }
        // verify the required parameter 'sortby' is set
        if ($sortby === null) {
            throw new \InvalidArgumentException('Missing the required parameter $sortby when calling getFileList');
        }
        // verify the required parameter 'start' is set
        if ($start === null) {
            throw new \InvalidArgumentException('Missing the required parameter $start when calling getFileList');
        }
        // verify the required parameter 'limit' is set
        if ($limit === null) {
            throw new \InvalidArgumentException('Missing the required parameter $limit when calling getFileList');
        }
        // parse inputs
        $resourcePath = "/core/getfilelist";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($path !== null) {
            $queryParams['path'] = $this->apiClient->getSerializer()->toQueryValue($path);
        }
        // query params
        if ($sortdir !== null) {
            $queryParams['sortdir'] = $this->apiClient->getSerializer()->toQueryValue($sortdir);
        }
        // query params
        if ($sortby !== null) {
            $queryParams['sortby'] = $this->apiClient->getSerializer()->toQueryValue($sortby);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = $this->apiClient->getSerializer()->toQueryValue($start);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = $this->apiClient->getSerializer()->toQueryValue($limit);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/core/getfilelist'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getFolderProperties
     *
     * 
     *
     * @param string $path Path of the folder (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getFolderProperties($path)
    {
        list($response) = $this->getFolderPropertiesWithHttpInfo($path);
        return $response;
    }

    /**
     * Operation getFolderPropertiesWithHttpInfo
     *
     * 
     *
     * @param string $path Path of the folder (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFolderPropertiesWithHttpInfo($path)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling getFolderProperties');
        }
        // parse inputs
        $resourcePath = "/core/getfolderproperties";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($path !== null) {
            $queryParams['path'] = $this->apiClient->getSerializer()->toQueryValue($path);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/core/getfolderproperties'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation renameFile
     *
     * 
     *
     * @param string $path Path of the file where it resides. (required)
     * @param string $name Name of the file to be renamed. (required)
     * @param string $newname Name of the file with the path where the file has to be moved. (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function renameFile($path, $name, $newname)
    {
        list($response) = $this->renameFileWithHttpInfo($path, $name, $newname);
        return $response;
    }

    /**
     * Operation renameFileWithHttpInfo
     *
     * 
     *
     * @param string $path Path of the file where it resides. (required)
     * @param string $name Name of the file to be renamed. (required)
     * @param string $newname Name of the file with the path where the file has to be moved. (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function renameFileWithHttpInfo($path, $name, $newname)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling renameFile');
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling renameFile');
        }
        // verify the required parameter 'newname' is set
        if ($newname === null) {
            throw new \InvalidArgumentException('Missing the required parameter $newname when calling renameFile');
        }
        // parse inputs
        $resourcePath = "/core/renamefile";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/x-www-form-urlencoded']);

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($path !== null) {
            $formParams['path'] = $this->apiClient->getSerializer()->toFormValue($path);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = $this->apiClient->getSerializer()->toFormValue($name);
        }
        // form params
        if ($newname !== null) {
            $formParams['newname'] = $this->apiClient->getSerializer()->toFormValue($newname);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/core/renamefile'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation renameOrMove
     *
     * 
     *
     * @param string $fromname Name of the file with the path where the file resides. (required)
     * @param string $toname Name of the file with the path where the file has to be moved. (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function renameOrMove($fromname, $toname)
    {
        list($response) = $this->renameOrMoveWithHttpInfo($fromname, $toname);
        return $response;
    }

    /**
     * Operation renameOrMoveWithHttpInfo
     *
     * 
     *
     * @param string $fromname Name of the file with the path where the file resides. (required)
     * @param string $toname Name of the file with the path where the file has to be moved. (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function renameOrMoveWithHttpInfo($fromname, $toname)
    {
        // verify the required parameter 'fromname' is set
        if ($fromname === null) {
            throw new \InvalidArgumentException('Missing the required parameter $fromname when calling renameOrMove');
        }
        // verify the required parameter 'toname' is set
        if ($toname === null) {
            throw new \InvalidArgumentException('Missing the required parameter $toname when calling renameOrMove');
        }
        // parse inputs
        $resourcePath = "/core/renameormove";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/x-www-form-urlencoded']);

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($fromname !== null) {
            $formParams['fromname'] = $this->apiClient->getSerializer()->toFormValue($fromname);
        }
        // form params
        if ($toname !== null) {
            $formParams['toname'] = $this->apiClient->getSerializer()->toFormValue($toname);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/core/renameormove'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation search
     *
     * 
     *
     * @param string $keyword Keyword to search (required)
     * @param string $location Specify the directory path in which you want to perform search. (required)
     * @param string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function search($keyword, $location, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        list($response) = $this->searchWithHttpInfo($keyword, $location, $minsize, $maxsize, $modifiedstart, $modifiedend);
        return $response;
    }

    /**
     * Operation searchWithHttpInfo
     *
     * 
     *
     * @param string $keyword Keyword to search (required)
     * @param string $location Specify the directory path in which you want to perform search. (required)
     * @param string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchWithHttpInfo($keyword, $location, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        // verify the required parameter 'keyword' is set
        if ($keyword === null) {
            throw new \InvalidArgumentException('Missing the required parameter $keyword when calling search');
        }
        // verify the required parameter 'location' is set
        if ($location === null) {
            throw new \InvalidArgumentException('Missing the required parameter $location when calling search');
        }
        // parse inputs
        $resourcePath = "/core/search";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/x-www-form-urlencoded']);

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($keyword !== null) {
            $formParams['keyword'] = $this->apiClient->getSerializer()->toFormValue($keyword);
        }
        // form params
        if ($location !== null) {
            $formParams['location'] = $this->apiClient->getSerializer()->toFormValue($location);
        }
        // form params
        if ($minsize !== null) {
            $formParams['minsize'] = $this->apiClient->getSerializer()->toFormValue($minsize);
        }
        // form params
        if ($maxsize !== null) {
            $formParams['maxsize'] = $this->apiClient->getSerializer()->toFormValue($maxsize);
        }
        // form params
        if ($modifiedstart !== null) {
            $formParams['modifiedstart'] = $this->apiClient->getSerializer()->toFormValue($modifiedstart);
        }
        // form params
        if ($modifiedend !== null) {
            $formParams['modifiedend'] = $this->apiClient->getSerializer()->toFormValue($modifiedend);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/core/search'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation searchExt
     *
     * 
     *
     * @param string $op Operantion name - searchcontent (required)
     * @param string $searchname Specify the filename to be searched. (required)
     * @param string $searchtext Specify the text to search (required)
     * @param string $searchloc (optional) Specify the directory path in which you want to perform search (if not specified user&#39;s home directory will be the path) (optional)
     * @param string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function searchExt($op, $searchname, $searchtext, $searchloc = null, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        list($response) = $this->searchExtWithHttpInfo($op, $searchname, $searchtext, $searchloc, $minsize, $maxsize, $modifiedstart, $modifiedend);
        return $response;
    }

    /**
     * Operation searchExtWithHttpInfo
     *
     * 
     *
     * @param string $op Operantion name - searchcontent (required)
     * @param string $searchname Specify the filename to be searched. (required)
     * @param string $searchtext Specify the text to search (required)
     * @param string $searchloc (optional) Specify the directory path in which you want to perform search (if not specified user&#39;s home directory will be the path) (optional)
     * @param string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (optional)
     * @param string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (optional)
     * @param string $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param string $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchExtWithHttpInfo($op, $searchname, $searchtext, $searchloc = null, $minsize = null, $maxsize = null, $modifiedstart = null, $modifiedend = null)
    {
        // verify the required parameter 'op' is set
        if ($op === null) {
            throw new \InvalidArgumentException('Missing the required parameter $op when calling searchExt');
        }
        // verify the required parameter 'searchname' is set
        if ($searchname === null) {
            throw new \InvalidArgumentException('Missing the required parameter $searchname when calling searchExt');
        }
        // verify the required parameter 'searchtext' is set
        if ($searchtext === null) {
            throw new \InvalidArgumentException('Missing the required parameter $searchtext when calling searchExt');
        }
        // parse inputs
        $resourcePath = "/app/searchext/";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/x-www-form-urlencoded']);

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($op !== null) {
            $formParams['op'] = $this->apiClient->getSerializer()->toFormValue($op);
        }
        // form params
        if ($searchname !== null) {
            $formParams['searchname'] = $this->apiClient->getSerializer()->toFormValue($searchname);
        }
        // form params
        if ($searchtext !== null) {
            $formParams['searchtext'] = $this->apiClient->getSerializer()->toFormValue($searchtext);
        }
        // form params
        if ($searchloc !== null) {
            $formParams['searchloc'] = $this->apiClient->getSerializer()->toFormValue($searchloc);
        }
        // form params
        if ($minsize !== null) {
            $formParams['minsize'] = $this->apiClient->getSerializer()->toFormValue($minsize);
        }
        // form params
        if ($maxsize !== null) {
            $formParams['maxsize'] = $this->apiClient->getSerializer()->toFormValue($maxsize);
        }
        // form params
        if ($modifiedstart !== null) {
            $formParams['modifiedstart'] = $this->apiClient->getSerializer()->toFormValue($modifiedstart);
        }
        // form params
        if ($modifiedend !== null) {
            $formParams['modifiedend'] = $this->apiClient->getSerializer()->toFormValue($modifiedend);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/app/searchext/'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation upload
     *
     * 
     *
     * @param string $appname Agent use to upload files to system (required)
     * @param string $path Specify the path where you want to upload the file (required)
     * @param float $offset Offset set to 0 (required)
     * @param float $complete Complete set to 1 (required)
     * @param string $filename File name to be uploaded (required)
     * @param \SplFileObject $fileContents The path to the file you want to upload. (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return void
     */
    public function upload($appname, $path, $offset, $complete, $filename, $fileContents)
    {
        list($response) = $this->uploadWithHttpInfo($appname, $path, $offset, $complete, $filename, $fileContents);
        return $response;
    }

    /**
     * Operation uploadWithHttpInfo
     *
     * 
     *
     * @param string $appname Agent use to upload files to system (required)
     * @param string $path Specify the path where you want to upload the file (required)
     * @param float $offset Offset set to 0 (required)
     * @param float $complete Complete set to 1 (required)
     * @param string $filename File name to be uploaded (required)
     * @param \SplFileObject $fileContents The path to the file you want to upload. (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadWithHttpInfo($appname, $path, $offset, $complete, $filename, $fileContents)
    {
        // verify the required parameter 'appname' is set
        if ($appname === null) {
            throw new \InvalidArgumentException('Missing the required parameter $appname when calling upload');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling upload');
        }
        // verify the required parameter 'offset' is set
        if ($offset === null) {
            throw new \InvalidArgumentException('Missing the required parameter $offset when calling upload');
        }
        // verify the required parameter 'complete' is set
        if ($complete === null) {
            throw new \InvalidArgumentException('Missing the required parameter $complete when calling upload');
        }
        // verify the required parameter 'filename' is set
        if ($filename === null) {
            throw new \InvalidArgumentException('Missing the required parameter $filename when calling upload');
        }
        // verify the required parameter 'fileContents' is set
        if ($fileContents === null) {
            throw new \InvalidArgumentException('Missing the required parameter $fileContents when calling upload');
        }
        // parse inputs
        $resourcePath = "/core/upload";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['multipart/form-data']);

        // query params
        if ($appname !== null) {
            $queryParams['appname'] = $this->apiClient->getSerializer()->toQueryValue($appname);
        }
        // query params
        if ($path !== null) {
            $queryParams['path'] = $this->apiClient->getSerializer()->toQueryValue($path);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = $this->apiClient->getSerializer()->toQueryValue($offset);
        }
        // query params
        if ($complete !== null) {
            $queryParams['complete'] = $this->apiClient->getSerializer()->toQueryValue($complete);
        }
        // query params
        if ($filename !== null) {
            $queryParams['filename'] = $this->apiClient->getSerializer()->toQueryValue($filename);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($fileContents !== null) {
            // PHP 5.5 introduced a CurlFile object that deprecates the old @filename syntax
            // See: https://wiki.php.net/rfc/curl-file-upload
            if (function_exists('curl_file_create')) {
                $formParams['file_contents'] = curl_file_create($this->apiClient->getSerializer()->toFormValue($fileContents));
            } else {
                $formParams['file_contents'] = '@' . $this->apiClient->getSerializer()->toFormValue($fileContents);
            }
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/core/upload'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }
}
