<?php
/**
 * FileApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * FileCloud_User_API
 *
 * FileCloud HTTP API
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * FileApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class FileApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation cancelsearch
     *
     * File_Related_API - cancelsearch lets user to cancel search while the search is in progress
     *
     * @param  string $searchid Specify the search ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function cancelsearch($searchid)
    {
        list($response) = $this->cancelsearchWithHttpInfo($searchid);
        return $response;
    }

    /**
     * Operation cancelsearchWithHttpInfo
     *
     * File_Related_API - cancelsearch lets user to cancel search while the search is in progress
     *
     * @param  string $searchid Specify the search ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelsearchWithHttpInfo($searchid)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->cancelsearchRequest($searchid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelsearchAsync
     *
     * File_Related_API - cancelsearch lets user to cancel search while the search is in progress
     *
     * @param  string $searchid Specify the search ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelsearchAsync($searchid)
    {
        return $this->cancelsearchAsyncWithHttpInfo($searchid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelsearchAsyncWithHttpInfo
     *
     * File_Related_API - cancelsearch lets user to cancel search while the search is in progress
     *
     * @param  string $searchid Specify the search ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelsearchAsyncWithHttpInfo($searchid)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->cancelsearchRequest($searchid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelsearch'
     *
     * @param  string $searchid Specify the search ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelsearchRequest($searchid)
    {
        // verify the required parameter 'searchid' is set
        if ($searchid === null || (is_array($searchid) && count($searchid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchid when calling cancelsearch'
            );
        }

        $resourcePath = '/core/cancelsearch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($searchid !== null) {
            $queryParams['searchid'] = ObjectSerializer::toQueryValue($searchid);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clearsavedsearchterms
     *
     * File_Related_API - clearsavedsearchterms is used to clear the previously saved search term
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function clearsavedsearchterms()
    {
        list($response) = $this->clearsavedsearchtermsWithHttpInfo();
        return $response;
    }

    /**
     * Operation clearsavedsearchtermsWithHttpInfo
     *
     * File_Related_API - clearsavedsearchterms is used to clear the previously saved search term
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function clearsavedsearchtermsWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->clearsavedsearchtermsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clearsavedsearchtermsAsync
     *
     * File_Related_API - clearsavedsearchterms is used to clear the previously saved search term
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearsavedsearchtermsAsync()
    {
        return $this->clearsavedsearchtermsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clearsavedsearchtermsAsyncWithHttpInfo
     *
     * File_Related_API - clearsavedsearchterms is used to clear the previously saved search term
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearsavedsearchtermsAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->clearsavedsearchtermsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clearsavedsearchterms'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clearsavedsearchtermsRequest()
    {

        $resourcePath = '/core/clearsavedsearchterms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation copyfile
     *
     * File_Related_API - copyfile is used to copy files from one path to another path
     *
     * @param  string $copyto Path where the files has to be copied (required)
     * @param  string $path Path where the files reside (required)
     * @param  string $name Name of the image file, eg- /Path/Image file name. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function copyfile($copyto, $path, $name)
    {
        list($response) = $this->copyfileWithHttpInfo($copyto, $path, $name);
        return $response;
    }

    /**
     * Operation copyfileWithHttpInfo
     *
     * File_Related_API - copyfile is used to copy files from one path to another path
     *
     * @param  string $copyto Path where the files has to be copied (required)
     * @param  string $path Path where the files reside (required)
     * @param  string $name Name of the image file, eg- /Path/Image file name. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyfileWithHttpInfo($copyto, $path, $name)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->copyfileRequest($copyto, $path, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation copyfileAsync
     *
     * File_Related_API - copyfile is used to copy files from one path to another path
     *
     * @param  string $copyto Path where the files has to be copied (required)
     * @param  string $path Path where the files reside (required)
     * @param  string $name Name of the image file, eg- /Path/Image file name. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyfileAsync($copyto, $path, $name)
    {
        return $this->copyfileAsyncWithHttpInfo($copyto, $path, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyfileAsyncWithHttpInfo
     *
     * File_Related_API - copyfile is used to copy files from one path to another path
     *
     * @param  string $copyto Path where the files has to be copied (required)
     * @param  string $path Path where the files reside (required)
     * @param  string $name Name of the image file, eg- /Path/Image file name. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyfileAsyncWithHttpInfo($copyto, $path, $name)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->copyfileRequest($copyto, $path, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyfile'
     *
     * @param  string $copyto Path where the files has to be copied (required)
     * @param  string $path Path where the files reside (required)
     * @param  string $name Name of the image file, eg- /Path/Image file name. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function copyfileRequest($copyto, $path, $name)
    {
        // verify the required parameter 'copyto' is set
        if ($copyto === null || (is_array($copyto) && count($copyto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $copyto when calling copyfile'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling copyfile'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling copyfile'
            );
        }

        $resourcePath = '/core/copyfile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($copyto !== null) {
            $queryParams['copyto'] = ObjectSerializer::toQueryValue($copyto);
        }
        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createfolder
     *
     * File_Related_API - createfolder lets user to create a folder in a particular path
     *
     * @param  string $name Name of the folder to be created (required)
     * @param  string $path Path where you want to create the folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function createfolder($name, $path)
    {
        list($response) = $this->createfolderWithHttpInfo($name, $path);
        return $response;
    }

    /**
     * Operation createfolderWithHttpInfo
     *
     * File_Related_API - createfolder lets user to create a folder in a particular path
     *
     * @param  string $name Name of the folder to be created (required)
     * @param  string $path Path where you want to create the folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function createfolderWithHttpInfo($name, $path)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->createfolderRequest($name, $path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createfolderAsync
     *
     * File_Related_API - createfolder lets user to create a folder in a particular path
     *
     * @param  string $name Name of the folder to be created (required)
     * @param  string $path Path where you want to create the folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createfolderAsync($name, $path)
    {
        return $this->createfolderAsyncWithHttpInfo($name, $path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createfolderAsyncWithHttpInfo
     *
     * File_Related_API - createfolder lets user to create a folder in a particular path
     *
     * @param  string $name Name of the folder to be created (required)
     * @param  string $path Path where you want to create the folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createfolderAsyncWithHttpInfo($name, $path)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->createfolderRequest($name, $path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createfolder'
     *
     * @param  string $name Name of the folder to be created (required)
     * @param  string $path Path where you want to create the folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createfolderRequest($name, $path)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling createfolder'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling createfolder'
            );
        }

        $resourcePath = '/app/explorer/createfolder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletefile
     *
     * File_Related_API - deletefile is used to delete a file/folder from particular location
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be deleted. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function deletefile($path, $name)
    {
        list($response) = $this->deletefileWithHttpInfo($path, $name);
        return $response;
    }

    /**
     * Operation deletefileWithHttpInfo
     *
     * File_Related_API - deletefile is used to delete a file/folder from particular location
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be deleted. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletefileWithHttpInfo($path, $name)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->deletefileRequest($path, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletefileAsync
     *
     * File_Related_API - deletefile is used to delete a file/folder from particular location
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletefileAsync($path, $name)
    {
        return $this->deletefileAsyncWithHttpInfo($path, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletefileAsyncWithHttpInfo
     *
     * File_Related_API - deletefile is used to delete a file/folder from particular location
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletefileAsyncWithHttpInfo($path, $name)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->deletefileRequest($path, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletefile'
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletefileRequest($path, $name)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling deletefile'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deletefile'
            );
        }

        $resourcePath = '/core/deletefile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletepartialuploads
     *
     * File_Related_API - deletepartialuploads is used to delete files which were uploaded partially
     *
     * @param  int $ignorets Set value to 1 to delete partial uploads using API call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function deletepartialuploads($ignorets)
    {
        list($response) = $this->deletepartialuploadsWithHttpInfo($ignorets);
        return $response;
    }

    /**
     * Operation deletepartialuploadsWithHttpInfo
     *
     * File_Related_API - deletepartialuploads is used to delete files which were uploaded partially
     *
     * @param  int $ignorets Set value to 1 to delete partial uploads using API call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletepartialuploadsWithHttpInfo($ignorets)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->deletepartialuploadsRequest($ignorets);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletepartialuploadsAsync
     *
     * File_Related_API - deletepartialuploads is used to delete files which were uploaded partially
     *
     * @param  int $ignorets Set value to 1 to delete partial uploads using API call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletepartialuploadsAsync($ignorets)
    {
        return $this->deletepartialuploadsAsyncWithHttpInfo($ignorets)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletepartialuploadsAsyncWithHttpInfo
     *
     * File_Related_API - deletepartialuploads is used to delete files which were uploaded partially
     *
     * @param  int $ignorets Set value to 1 to delete partial uploads using API call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletepartialuploadsAsyncWithHttpInfo($ignorets)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->deletepartialuploadsRequest($ignorets);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletepartialuploads'
     *
     * @param  int $ignorets Set value to 1 to delete partial uploads using API call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletepartialuploadsRequest($ignorets)
    {
        // verify the required parameter 'ignorets' is set
        if ($ignorets === null || (is_array($ignorets) && count($ignorets) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ignorets when calling deletepartialuploads'
            );
        }

        $resourcePath = '/core/deletepartialuploads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ignorets !== null) {
            $queryParams['ignorets'] = ObjectSerializer::toQueryValue($ignorets);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation docconvert
     *
     * File_Related_API - docconvert is used to preview files
     *
     * @param  string $name Specify the file location (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function docconvert($name)
    {
        list($response) = $this->docconvertWithHttpInfo($name);
        return $response;
    }

    /**
     * Operation docconvertWithHttpInfo
     *
     * File_Related_API - docconvert is used to preview files
     *
     * @param  string $name Specify the file location (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function docconvertWithHttpInfo($name)
    {
        $returnType = 'string';
        $request = $this->docconvertRequest($name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation docconvertAsync
     *
     * File_Related_API - docconvert is used to preview files
     *
     * @param  string $name Specify the file location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function docconvertAsync($name)
    {
        return $this->docconvertAsyncWithHttpInfo($name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation docconvertAsyncWithHttpInfo
     *
     * File_Related_API - docconvert is used to preview files
     *
     * @param  string $name Specify the file location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function docconvertAsyncWithHttpInfo($name)
    {
        $returnType = 'string';
        $request = $this->docconvertRequest($name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'docconvert'
     *
     * @param  string $name Specify the file location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function docconvertRequest($name)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling docconvert'
            );
        }

        $resourcePath = '/core/docconvert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation docedit
     *
     * File_Related_API - docedit is used to edit documents
     *
     * @param  string $path Path of the file where it resides (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function docedit($path)
    {
        list($response) = $this->doceditWithHttpInfo($path);
        return $response;
    }

    /**
     * Operation doceditWithHttpInfo
     *
     * File_Related_API - docedit is used to edit documents
     *
     * @param  string $path Path of the file where it resides (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function doceditWithHttpInfo($path)
    {
        $returnType = 'string';
        $request = $this->doceditRequest($path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation doceditAsync
     *
     * File_Related_API - docedit is used to edit documents
     *
     * @param  string $path Path of the file where it resides (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function doceditAsync($path)
    {
        return $this->doceditAsyncWithHttpInfo($path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation doceditAsyncWithHttpInfo
     *
     * File_Related_API - docedit is used to edit documents
     *
     * @param  string $path Path of the file where it resides (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function doceditAsyncWithHttpInfo($path)
    {
        $returnType = 'string';
        $request = $this->doceditRequest($path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'docedit'
     *
     * @param  string $path Path of the file where it resides (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function doceditRequest($path)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling docedit'
            );
        }

        $resourcePath = '/core/docedit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dosearch
     *
     * File_Related_API - dosearch is used to search for a file or folder
     *
     * @param  string $searchstring Keyword to search (required)
     * @param  string $searchloc Specify the directory path in which you want to perform search. (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (required)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (required)
     * @param  float $searchscope Specify the search scope (required)
     * @param  float $start Set to 0 (required)
     * @param  float $size Specify the search record limit value (required)
     * @param  float $maxsearchentries Maximum number of search entries (required)
     * @param  \DateTime $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  \DateTime $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Entries
     */
    public function dosearch($searchstring, $searchloc, $minsize, $maxsize, $searchscope, $start, $size, $maxsearchentries, $modifiedstart = null, $modifiedend = null)
    {
        list($response) = $this->dosearchWithHttpInfo($searchstring, $searchloc, $minsize, $maxsize, $searchscope, $start, $size, $maxsearchentries, $modifiedstart, $modifiedend);
        return $response;
    }

    /**
     * Operation dosearchWithHttpInfo
     *
     * File_Related_API - dosearch is used to search for a file or folder
     *
     * @param  string $searchstring Keyword to search (required)
     * @param  string $searchloc Specify the directory path in which you want to perform search. (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (required)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (required)
     * @param  float $searchscope Specify the search scope (required)
     * @param  float $start Set to 0 (required)
     * @param  float $size Specify the search record limit value (required)
     * @param  float $maxsearchentries Maximum number of search entries (required)
     * @param  \DateTime $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  \DateTime $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Entries, HTTP status code, HTTP response headers (array of strings)
     */
    public function dosearchWithHttpInfo($searchstring, $searchloc, $minsize, $maxsize, $searchscope, $start, $size, $maxsearchentries, $modifiedstart = null, $modifiedend = null)
    {
        $returnType = '\Swagger\Client\Model\Entries';
        $request = $this->dosearchRequest($searchstring, $searchloc, $minsize, $maxsize, $searchscope, $start, $size, $maxsearchentries, $modifiedstart, $modifiedend);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Entries',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dosearchAsync
     *
     * File_Related_API - dosearch is used to search for a file or folder
     *
     * @param  string $searchstring Keyword to search (required)
     * @param  string $searchloc Specify the directory path in which you want to perform search. (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (required)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (required)
     * @param  float $searchscope Specify the search scope (required)
     * @param  float $start Set to 0 (required)
     * @param  float $size Specify the search record limit value (required)
     * @param  float $maxsearchentries Maximum number of search entries (required)
     * @param  \DateTime $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  \DateTime $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dosearchAsync($searchstring, $searchloc, $minsize, $maxsize, $searchscope, $start, $size, $maxsearchentries, $modifiedstart = null, $modifiedend = null)
    {
        return $this->dosearchAsyncWithHttpInfo($searchstring, $searchloc, $minsize, $maxsize, $searchscope, $start, $size, $maxsearchentries, $modifiedstart, $modifiedend)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dosearchAsyncWithHttpInfo
     *
     * File_Related_API - dosearch is used to search for a file or folder
     *
     * @param  string $searchstring Keyword to search (required)
     * @param  string $searchloc Specify the directory path in which you want to perform search. (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (required)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (required)
     * @param  float $searchscope Specify the search scope (required)
     * @param  float $start Set to 0 (required)
     * @param  float $size Specify the search record limit value (required)
     * @param  float $maxsearchentries Maximum number of search entries (required)
     * @param  \DateTime $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  \DateTime $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dosearchAsyncWithHttpInfo($searchstring, $searchloc, $minsize, $maxsize, $searchscope, $start, $size, $maxsearchentries, $modifiedstart = null, $modifiedend = null)
    {
        $returnType = '\Swagger\Client\Model\Entries';
        $request = $this->dosearchRequest($searchstring, $searchloc, $minsize, $maxsize, $searchscope, $start, $size, $maxsearchentries, $modifiedstart, $modifiedend);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dosearch'
     *
     * @param  string $searchstring Keyword to search (required)
     * @param  string $searchloc Specify the directory path in which you want to perform search. (required)
     * @param  string $minsize (optional)Specify the size in kb, the search will show files that is greater than and equal to the size mentioned. (required)
     * @param  string $maxsize (optional)Specify the size in kb, the search will show files that is lesser than and equal to the size mentioned. (required)
     * @param  float $searchscope Specify the search scope (required)
     * @param  float $start Set to 0 (required)
     * @param  float $size Specify the search record limit value (required)
     * @param  float $maxsearchentries Maximum number of search entries (required)
     * @param  \DateTime $modifiedstart (optional)Specify the value in date format, the search will show files that was created on and after the date mentioned (optional)
     * @param  \DateTime $modifiedend (optional)Specify the value in date format, the search will show files that was created before the date mentioned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dosearchRequest($searchstring, $searchloc, $minsize, $maxsize, $searchscope, $start, $size, $maxsearchentries, $modifiedstart = null, $modifiedend = null)
    {
        // verify the required parameter 'searchstring' is set
        if ($searchstring === null || (is_array($searchstring) && count($searchstring) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchstring when calling dosearch'
            );
        }
        // verify the required parameter 'searchloc' is set
        if ($searchloc === null || (is_array($searchloc) && count($searchloc) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchloc when calling dosearch'
            );
        }
        // verify the required parameter 'minsize' is set
        if ($minsize === null || (is_array($minsize) && count($minsize) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $minsize when calling dosearch'
            );
        }
        // verify the required parameter 'maxsize' is set
        if ($maxsize === null || (is_array($maxsize) && count($maxsize) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $maxsize when calling dosearch'
            );
        }
        // verify the required parameter 'searchscope' is set
        if ($searchscope === null || (is_array($searchscope) && count($searchscope) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchscope when calling dosearch'
            );
        }
        // verify the required parameter 'start' is set
        if ($start === null || (is_array($start) && count($start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start when calling dosearch'
            );
        }
        // verify the required parameter 'size' is set
        if ($size === null || (is_array($size) && count($size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $size when calling dosearch'
            );
        }
        // verify the required parameter 'maxsearchentries' is set
        if ($maxsearchentries === null || (is_array($maxsearchentries) && count($maxsearchentries) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $maxsearchentries when calling dosearch'
            );
        }

        $resourcePath = '/core/dosearch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($searchstring !== null) {
            $queryParams['searchstring'] = ObjectSerializer::toQueryValue($searchstring);
        }
        // query params
        if ($searchloc !== null) {
            $queryParams['searchloc'] = ObjectSerializer::toQueryValue($searchloc);
        }
        // query params
        if ($minsize !== null) {
            $queryParams['minsize'] = ObjectSerializer::toQueryValue($minsize);
        }
        // query params
        if ($maxsize !== null) {
            $queryParams['maxsize'] = ObjectSerializer::toQueryValue($maxsize);
        }
        // query params
        if ($modifiedstart !== null) {
            $queryParams['modifiedstart'] = ObjectSerializer::toQueryValue($modifiedstart);
        }
        // query params
        if ($modifiedend !== null) {
            $queryParams['modifiedend'] = ObjectSerializer::toQueryValue($modifiedend);
        }
        // query params
        if ($searchscope !== null) {
            $queryParams['searchscope'] = ObjectSerializer::toQueryValue($searchscope);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size);
        }
        // query params
        if ($maxsearchentries !== null) {
            $queryParams['maxsearchentries'] = ObjectSerializer::toQueryValue($maxsearchentries);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadfile
     *
     * File_Related_API - downloadfile is used to download files from a location
     *
     * @param  string $filepath Path of the file where it resides and with the name of the file to be downloaded. (required)
     * @param  string $filename Name of the file to be downloaded (required)
     * @param  string $redirect (Optional)Set it to 1 to directly download from Amazon S3 (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function downloadfile($filepath, $filename, $redirect = null)
    {
        list($response) = $this->downloadfileWithHttpInfo($filepath, $filename, $redirect);
        return $response;
    }

    /**
     * Operation downloadfileWithHttpInfo
     *
     * File_Related_API - downloadfile is used to download files from a location
     *
     * @param  string $filepath Path of the file where it resides and with the name of the file to be downloaded. (required)
     * @param  string $filename Name of the file to be downloaded (required)
     * @param  string $redirect (Optional)Set it to 1 to directly download from Amazon S3 (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadfileWithHttpInfo($filepath, $filename, $redirect = null)
    {
        $returnType = 'string';
        $request = $this->downloadfileRequest($filepath, $filename, $redirect);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadfileAsync
     *
     * File_Related_API - downloadfile is used to download files from a location
     *
     * @param  string $filepath Path of the file where it resides and with the name of the file to be downloaded. (required)
     * @param  string $filename Name of the file to be downloaded (required)
     * @param  string $redirect (Optional)Set it to 1 to directly download from Amazon S3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadfileAsync($filepath, $filename, $redirect = null)
    {
        return $this->downloadfileAsyncWithHttpInfo($filepath, $filename, $redirect)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadfileAsyncWithHttpInfo
     *
     * File_Related_API - downloadfile is used to download files from a location
     *
     * @param  string $filepath Path of the file where it resides and with the name of the file to be downloaded. (required)
     * @param  string $filename Name of the file to be downloaded (required)
     * @param  string $redirect (Optional)Set it to 1 to directly download from Amazon S3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadfileAsyncWithHttpInfo($filepath, $filename, $redirect = null)
    {
        $returnType = 'string';
        $request = $this->downloadfileRequest($filepath, $filename, $redirect);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadfile'
     *
     * @param  string $filepath Path of the file where it resides and with the name of the file to be downloaded. (required)
     * @param  string $filename Name of the file to be downloaded (required)
     * @param  string $redirect (Optional)Set it to 1 to directly download from Amazon S3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function downloadfileRequest($filepath, $filename, $redirect = null)
    {
        // verify the required parameter 'filepath' is set
        if ($filepath === null || (is_array($filepath) && count($filepath) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filepath when calling downloadfile'
            );
        }
        // verify the required parameter 'filename' is set
        if ($filename === null || (is_array($filename) && count($filename) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filename when calling downloadfile'
            );
        }

        $resourcePath = '/core/downloadfile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filepath !== null) {
            $queryParams['filepath'] = ObjectSerializer::toQueryValue($filepath);
        }
        // query params
        if ($filename !== null) {
            $queryParams['filename'] = ObjectSerializer::toQueryValue($filename);
        }
        // query params
        if ($redirect !== null) {
            $queryParams['redirect'] = ObjectSerializer::toQueryValue($redirect);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadfilemulti
     *
     * File_Related_API - downloadfilemulti is used to download multiple files
     *
     * @param  float $count Number of files to be downloaded (required)
     * @param  string $filepath Path of the file where it resides. (required)
     * @param  string $fn1 First file name selected for download (required)
     * @param  string $fn2 Second file name selected for download {To downlaod more keep adding param&#39;s like fn3, fn4..} (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function downloadfilemulti($count, $filepath, $fn1, $fn2)
    {
        list($response) = $this->downloadfilemultiWithHttpInfo($count, $filepath, $fn1, $fn2);
        return $response;
    }

    /**
     * Operation downloadfilemultiWithHttpInfo
     *
     * File_Related_API - downloadfilemulti is used to download multiple files
     *
     * @param  float $count Number of files to be downloaded (required)
     * @param  string $filepath Path of the file where it resides. (required)
     * @param  string $fn1 First file name selected for download (required)
     * @param  string $fn2 Second file name selected for download {To downlaod more keep adding param&#39;s like fn3, fn4..} (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadfilemultiWithHttpInfo($count, $filepath, $fn1, $fn2)
    {
        $returnType = 'string';
        $request = $this->downloadfilemultiRequest($count, $filepath, $fn1, $fn2);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadfilemultiAsync
     *
     * File_Related_API - downloadfilemulti is used to download multiple files
     *
     * @param  float $count Number of files to be downloaded (required)
     * @param  string $filepath Path of the file where it resides. (required)
     * @param  string $fn1 First file name selected for download (required)
     * @param  string $fn2 Second file name selected for download {To downlaod more keep adding param&#39;s like fn3, fn4..} (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadfilemultiAsync($count, $filepath, $fn1, $fn2)
    {
        return $this->downloadfilemultiAsyncWithHttpInfo($count, $filepath, $fn1, $fn2)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadfilemultiAsyncWithHttpInfo
     *
     * File_Related_API - downloadfilemulti is used to download multiple files
     *
     * @param  float $count Number of files to be downloaded (required)
     * @param  string $filepath Path of the file where it resides. (required)
     * @param  string $fn1 First file name selected for download (required)
     * @param  string $fn2 Second file name selected for download {To downlaod more keep adding param&#39;s like fn3, fn4..} (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadfilemultiAsyncWithHttpInfo($count, $filepath, $fn1, $fn2)
    {
        $returnType = 'string';
        $request = $this->downloadfilemultiRequest($count, $filepath, $fn1, $fn2);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadfilemulti'
     *
     * @param  float $count Number of files to be downloaded (required)
     * @param  string $filepath Path of the file where it resides. (required)
     * @param  string $fn1 First file name selected for download (required)
     * @param  string $fn2 Second file name selected for download {To downlaod more keep adding param&#39;s like fn3, fn4..} (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function downloadfilemultiRequest($count, $filepath, $fn1, $fn2)
    {
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling downloadfilemulti'
            );
        }
        // verify the required parameter 'filepath' is set
        if ($filepath === null || (is_array($filepath) && count($filepath) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filepath when calling downloadfilemulti'
            );
        }
        // verify the required parameter 'fn1' is set
        if ($fn1 === null || (is_array($fn1) && count($fn1) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fn1 when calling downloadfilemulti'
            );
        }
        // verify the required parameter 'fn2' is set
        if ($fn2 === null || (is_array($fn2) && count($fn2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fn2 when calling downloadfilemulti'
            );
        }

        $resourcePath = '/core/downloadfilemulti';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count);
        }
        // query params
        if ($filepath !== null) {
            $queryParams['filepath'] = ObjectSerializer::toQueryValue($filepath);
        }
        // query params
        if ($fn1 !== null) {
            $queryParams['fn1'] = ObjectSerializer::toQueryValue($fn1);
        }
        // query params
        if ($fn2 !== null) {
            $queryParams['fn2'] = ObjectSerializer::toQueryValue($fn2);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation emptyrecyclebin
     *
     * File_Related_API - emptyrecyclebin is used to empty the user's recycly bin
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function emptyrecyclebin()
    {
        list($response) = $this->emptyrecyclebinWithHttpInfo();
        return $response;
    }

    /**
     * Operation emptyrecyclebinWithHttpInfo
     *
     * File_Related_API - emptyrecyclebin is used to empty the user's recycly bin
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function emptyrecyclebinWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->emptyrecyclebinRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation emptyrecyclebinAsync
     *
     * File_Related_API - emptyrecyclebin is used to empty the user's recycly bin
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function emptyrecyclebinAsync()
    {
        return $this->emptyrecyclebinAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation emptyrecyclebinAsyncWithHttpInfo
     *
     * File_Related_API - emptyrecyclebin is used to empty the user's recycly bin
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function emptyrecyclebinAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->emptyrecyclebinRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'emptyrecyclebin'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function emptyrecyclebinRequest()
    {

        $resourcePath = '/core/emptyrecyclebin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fileexists
     *
     * File_Related_API - fileexists is used to check if a file exists or not
     *
     * @param  string $file Path of the file where it resides (required)
     * @param  bool $caseinsensitive when this param is set to 1, fileexist call will disable the upper/lower case check in filenames.(can be 0 or 1) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function fileexists($file, $caseinsensitive = null)
    {
        list($response) = $this->fileexistsWithHttpInfo($file, $caseinsensitive);
        return $response;
    }

    /**
     * Operation fileexistsWithHttpInfo
     *
     * File_Related_API - fileexists is used to check if a file exists or not
     *
     * @param  string $file Path of the file where it resides (required)
     * @param  bool $caseinsensitive when this param is set to 1, fileexist call will disable the upper/lower case check in filenames.(can be 0 or 1) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function fileexistsWithHttpInfo($file, $caseinsensitive = null)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->fileexistsRequest($file, $caseinsensitive);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fileexistsAsync
     *
     * File_Related_API - fileexists is used to check if a file exists or not
     *
     * @param  string $file Path of the file where it resides (required)
     * @param  bool $caseinsensitive when this param is set to 1, fileexist call will disable the upper/lower case check in filenames.(can be 0 or 1) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fileexistsAsync($file, $caseinsensitive = null)
    {
        return $this->fileexistsAsyncWithHttpInfo($file, $caseinsensitive)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fileexistsAsyncWithHttpInfo
     *
     * File_Related_API - fileexists is used to check if a file exists or not
     *
     * @param  string $file Path of the file where it resides (required)
     * @param  bool $caseinsensitive when this param is set to 1, fileexist call will disable the upper/lower case check in filenames.(can be 0 or 1) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fileexistsAsyncWithHttpInfo($file, $caseinsensitive = null)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->fileexistsRequest($file, $caseinsensitive);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fileexists'
     *
     * @param  string $file Path of the file where it resides (required)
     * @param  bool $caseinsensitive when this param is set to 1, fileexist call will disable the upper/lower case check in filenames.(can be 0 or 1) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function fileexistsRequest($file, $caseinsensitive = null)
    {
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling fileexists'
            );
        }

        $resourcePath = '/core/fileexists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($file !== null) {
            $queryParams['file'] = ObjectSerializer::toQueryValue($file);
        }
        // query params
        if ($caseinsensitive !== null) {
            $queryParams['caseinsensitive'] = ObjectSerializer::toQueryValue($caseinsensitive);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fileinfo
     *
     * File_Related_API - fileinfo is used to view information about file
     *
     * @param  string $file Path of file to be specified (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Fileinfo
     */
    public function fileinfo($file)
    {
        list($response) = $this->fileinfoWithHttpInfo($file);
        return $response;
    }

    /**
     * Operation fileinfoWithHttpInfo
     *
     * File_Related_API - fileinfo is used to view information about file
     *
     * @param  string $file Path of file to be specified (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Fileinfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function fileinfoWithHttpInfo($file)
    {
        $returnType = '\Swagger\Client\Model\Fileinfo';
        $request = $this->fileinfoRequest($file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Fileinfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fileinfoAsync
     *
     * File_Related_API - fileinfo is used to view information about file
     *
     * @param  string $file Path of file to be specified (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fileinfoAsync($file)
    {
        return $this->fileinfoAsyncWithHttpInfo($file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fileinfoAsyncWithHttpInfo
     *
     * File_Related_API - fileinfo is used to view information about file
     *
     * @param  string $file Path of file to be specified (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fileinfoAsyncWithHttpInfo($file)
    {
        $returnType = '\Swagger\Client\Model\Fileinfo';
        $request = $this->fileinfoRequest($file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fileinfo'
     *
     * @param  string $file Path of file to be specified (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function fileinfoRequest($file)
    {
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling fileinfo'
            );
        }

        $resourcePath = '/core/fileinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($file !== null) {
            $queryParams['file'] = ObjectSerializer::toQueryValue($file);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getaccessdetailsforpath
     *
     * File_Related_API - getaccessdetailsforpath is used to get permission a file/folder has in the system
     *
     * @param  string $fullpath Path of the file/folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Permissions
     */
    public function getaccessdetailsforpath($fullpath)
    {
        list($response) = $this->getaccessdetailsforpathWithHttpInfo($fullpath);
        return $response;
    }

    /**
     * Operation getaccessdetailsforpathWithHttpInfo
     *
     * File_Related_API - getaccessdetailsforpath is used to get permission a file/folder has in the system
     *
     * @param  string $fullpath Path of the file/folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Permissions, HTTP status code, HTTP response headers (array of strings)
     */
    public function getaccessdetailsforpathWithHttpInfo($fullpath)
    {
        $returnType = '\Swagger\Client\Model\Permissions';
        $request = $this->getaccessdetailsforpathRequest($fullpath);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Permissions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getaccessdetailsforpathAsync
     *
     * File_Related_API - getaccessdetailsforpath is used to get permission a file/folder has in the system
     *
     * @param  string $fullpath Path of the file/folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getaccessdetailsforpathAsync($fullpath)
    {
        return $this->getaccessdetailsforpathAsyncWithHttpInfo($fullpath)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getaccessdetailsforpathAsyncWithHttpInfo
     *
     * File_Related_API - getaccessdetailsforpath is used to get permission a file/folder has in the system
     *
     * @param  string $fullpath Path of the file/folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getaccessdetailsforpathAsyncWithHttpInfo($fullpath)
    {
        $returnType = '\Swagger\Client\Model\Permissions';
        $request = $this->getaccessdetailsforpathRequest($fullpath);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getaccessdetailsforpath'
     *
     * @param  string $fullpath Path of the file/folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getaccessdetailsforpathRequest($fullpath)
    {
        // verify the required parameter 'fullpath' is set
        if ($fullpath === null || (is_array($fullpath) && count($fullpath) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fullpath when calling getaccessdetailsforpath'
            );
        }

        $resourcePath = '/core/getaccessdetailsforpath';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fullpath !== null) {
            $queryParams['fullpath'] = ObjectSerializer::toQueryValue($fullpath);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getfilelist
     *
     * File_Related_API - getfilelist is used to navigate through files
     *
     * @param  string $path Path Name to be specified, If the user wants to access MyFiles then use the username as path. (required)
     * @param  string $sortdir Set it to 1 for ascending sort , -1 for descending sort (required)
     * @param  string $sortby You can sort by name, date or size. (required)
     * @param  string $start Start index of records to retrieve, Note- Index starts from 0. Default 0 (required)
     * @param  string $limit Set to any number of record you want to view at once. Default 10 (required)
     * @param  string $sendcommentinfo whether to send comment info...value is either 1 or 0 (required)
     * @param  string $sendmetadatasetinfo whether to send metadata set info...value is either 1 or 0 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Entries
     */
    public function getfilelist($path, $sortdir, $sortby, $start, $limit, $sendcommentinfo, $sendmetadatasetinfo)
    {
        list($response) = $this->getfilelistWithHttpInfo($path, $sortdir, $sortby, $start, $limit, $sendcommentinfo, $sendmetadatasetinfo);
        return $response;
    }

    /**
     * Operation getfilelistWithHttpInfo
     *
     * File_Related_API - getfilelist is used to navigate through files
     *
     * @param  string $path Path Name to be specified, If the user wants to access MyFiles then use the username as path. (required)
     * @param  string $sortdir Set it to 1 for ascending sort , -1 for descending sort (required)
     * @param  string $sortby You can sort by name, date or size. (required)
     * @param  string $start Start index of records to retrieve, Note- Index starts from 0. Default 0 (required)
     * @param  string $limit Set to any number of record you want to view at once. Default 10 (required)
     * @param  string $sendcommentinfo whether to send comment info...value is either 1 or 0 (required)
     * @param  string $sendmetadatasetinfo whether to send metadata set info...value is either 1 or 0 (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Entries, HTTP status code, HTTP response headers (array of strings)
     */
    public function getfilelistWithHttpInfo($path, $sortdir, $sortby, $start, $limit, $sendcommentinfo, $sendmetadatasetinfo)
    {
        $returnType = '\Swagger\Client\Model\Entries';
        $request = $this->getfilelistRequest($path, $sortdir, $sortby, $start, $limit, $sendcommentinfo, $sendmetadatasetinfo);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Entries',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getfilelistAsync
     *
     * File_Related_API - getfilelist is used to navigate through files
     *
     * @param  string $path Path Name to be specified, If the user wants to access MyFiles then use the username as path. (required)
     * @param  string $sortdir Set it to 1 for ascending sort , -1 for descending sort (required)
     * @param  string $sortby You can sort by name, date or size. (required)
     * @param  string $start Start index of records to retrieve, Note- Index starts from 0. Default 0 (required)
     * @param  string $limit Set to any number of record you want to view at once. Default 10 (required)
     * @param  string $sendcommentinfo whether to send comment info...value is either 1 or 0 (required)
     * @param  string $sendmetadatasetinfo whether to send metadata set info...value is either 1 or 0 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getfilelistAsync($path, $sortdir, $sortby, $start, $limit, $sendcommentinfo, $sendmetadatasetinfo)
    {
        return $this->getfilelistAsyncWithHttpInfo($path, $sortdir, $sortby, $start, $limit, $sendcommentinfo, $sendmetadatasetinfo)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getfilelistAsyncWithHttpInfo
     *
     * File_Related_API - getfilelist is used to navigate through files
     *
     * @param  string $path Path Name to be specified, If the user wants to access MyFiles then use the username as path. (required)
     * @param  string $sortdir Set it to 1 for ascending sort , -1 for descending sort (required)
     * @param  string $sortby You can sort by name, date or size. (required)
     * @param  string $start Start index of records to retrieve, Note- Index starts from 0. Default 0 (required)
     * @param  string $limit Set to any number of record you want to view at once. Default 10 (required)
     * @param  string $sendcommentinfo whether to send comment info...value is either 1 or 0 (required)
     * @param  string $sendmetadatasetinfo whether to send metadata set info...value is either 1 or 0 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getfilelistAsyncWithHttpInfo($path, $sortdir, $sortby, $start, $limit, $sendcommentinfo, $sendmetadatasetinfo)
    {
        $returnType = '\Swagger\Client\Model\Entries';
        $request = $this->getfilelistRequest($path, $sortdir, $sortby, $start, $limit, $sendcommentinfo, $sendmetadatasetinfo);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getfilelist'
     *
     * @param  string $path Path Name to be specified, If the user wants to access MyFiles then use the username as path. (required)
     * @param  string $sortdir Set it to 1 for ascending sort , -1 for descending sort (required)
     * @param  string $sortby You can sort by name, date or size. (required)
     * @param  string $start Start index of records to retrieve, Note- Index starts from 0. Default 0 (required)
     * @param  string $limit Set to any number of record you want to view at once. Default 10 (required)
     * @param  string $sendcommentinfo whether to send comment info...value is either 1 or 0 (required)
     * @param  string $sendmetadatasetinfo whether to send metadata set info...value is either 1 or 0 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getfilelistRequest($path, $sortdir, $sortby, $start, $limit, $sendcommentinfo, $sendmetadatasetinfo)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getfilelist'
            );
        }
        // verify the required parameter 'sortdir' is set
        if ($sortdir === null || (is_array($sortdir) && count($sortdir) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sortdir when calling getfilelist'
            );
        }
        // verify the required parameter 'sortby' is set
        if ($sortby === null || (is_array($sortby) && count($sortby) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sortby when calling getfilelist'
            );
        }
        // verify the required parameter 'start' is set
        if ($start === null || (is_array($start) && count($start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start when calling getfilelist'
            );
        }
        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling getfilelist'
            );
        }
        // verify the required parameter 'sendcommentinfo' is set
        if ($sendcommentinfo === null || (is_array($sendcommentinfo) && count($sendcommentinfo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendcommentinfo when calling getfilelist'
            );
        }
        // verify the required parameter 'sendmetadatasetinfo' is set
        if ($sendmetadatasetinfo === null || (is_array($sendmetadatasetinfo) && count($sendmetadatasetinfo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendmetadatasetinfo when calling getfilelist'
            );
        }

        $resourcePath = '/core/getfilelist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($sortdir !== null) {
            $queryParams['sortdir'] = ObjectSerializer::toQueryValue($sortdir);
        }
        // query params
        if ($sortby !== null) {
            $queryParams['sortby'] = ObjectSerializer::toQueryValue($sortby);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($sendcommentinfo !== null) {
            $queryParams['sendcommentinfo'] = ObjectSerializer::toQueryValue($sendcommentinfo);
        }
        // query params
        if ($sendmetadatasetinfo !== null) {
            $queryParams['sendmetadatasetinfo'] = ObjectSerializer::toQueryValue($sendmetadatasetinfo);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getfolderproperties
     *
     * File_Related_API - getfolderproperties is used to see the contents of the folder
     *
     * @param  string $path Path of the folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Folderproperties
     */
    public function getfolderproperties($path)
    {
        list($response) = $this->getfolderpropertiesWithHttpInfo($path);
        return $response;
    }

    /**
     * Operation getfolderpropertiesWithHttpInfo
     *
     * File_Related_API - getfolderproperties is used to see the contents of the folder
     *
     * @param  string $path Path of the folder (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Folderproperties, HTTP status code, HTTP response headers (array of strings)
     */
    public function getfolderpropertiesWithHttpInfo($path)
    {
        $returnType = '\Swagger\Client\Model\Folderproperties';
        $request = $this->getfolderpropertiesRequest($path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Folderproperties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getfolderpropertiesAsync
     *
     * File_Related_API - getfolderproperties is used to see the contents of the folder
     *
     * @param  string $path Path of the folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getfolderpropertiesAsync($path)
    {
        return $this->getfolderpropertiesAsyncWithHttpInfo($path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getfolderpropertiesAsyncWithHttpInfo
     *
     * File_Related_API - getfolderproperties is used to see the contents of the folder
     *
     * @param  string $path Path of the folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getfolderpropertiesAsyncWithHttpInfo($path)
    {
        $returnType = '\Swagger\Client\Model\Folderproperties';
        $request = $this->getfolderpropertiesRequest($path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getfolderproperties'
     *
     * @param  string $path Path of the folder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getfolderpropertiesRequest($path)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getfolderproperties'
            );
        }

        $resourcePath = '/core/getfolderproperties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getwopiediturl
     *
     * File_Related_API - getwopiediturl is used for online editing for supported documents
     *
     * @param  string $path Specify the location of file (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getwopiediturl($path)
    {
        list($response) = $this->getwopiediturlWithHttpInfo($path);
        return $response;
    }

    /**
     * Operation getwopiediturlWithHttpInfo
     *
     * File_Related_API - getwopiediturl is used for online editing for supported documents
     *
     * @param  string $path Specify the location of file (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getwopiediturlWithHttpInfo($path)
    {
        $returnType = 'string';
        $request = $this->getwopiediturlRequest($path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getwopiediturlAsync
     *
     * File_Related_API - getwopiediturl is used for online editing for supported documents
     *
     * @param  string $path Specify the location of file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getwopiediturlAsync($path)
    {
        return $this->getwopiediturlAsyncWithHttpInfo($path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getwopiediturlAsyncWithHttpInfo
     *
     * File_Related_API - getwopiediturl is used for online editing for supported documents
     *
     * @param  string $path Specify the location of file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getwopiediturlAsyncWithHttpInfo($path)
    {
        $returnType = 'string';
        $request = $this->getwopiediturlRequest($path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getwopiediturl'
     *
     * @param  string $path Specify the location of file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getwopiediturlRequest($path)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getwopiediturl'
            );
        }

        $resourcePath = '/core/getwopiediturl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation renamefile
     *
     * File_Related_API - renamefile is used to rename a file in any particular location
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be renamed. (required)
     * @param  string $newname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function renamefile($path, $name, $newname)
    {
        list($response) = $this->renamefileWithHttpInfo($path, $name, $newname);
        return $response;
    }

    /**
     * Operation renamefileWithHttpInfo
     *
     * File_Related_API - renamefile is used to rename a file in any particular location
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be renamed. (required)
     * @param  string $newname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function renamefileWithHttpInfo($path, $name, $newname)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->renamefileRequest($path, $name, $newname);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation renamefileAsync
     *
     * File_Related_API - renamefile is used to rename a file in any particular location
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be renamed. (required)
     * @param  string $newname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renamefileAsync($path, $name, $newname)
    {
        return $this->renamefileAsyncWithHttpInfo($path, $name, $newname)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation renamefileAsyncWithHttpInfo
     *
     * File_Related_API - renamefile is used to rename a file in any particular location
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be renamed. (required)
     * @param  string $newname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renamefileAsyncWithHttpInfo($path, $name, $newname)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->renamefileRequest($path, $name, $newname);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'renamefile'
     *
     * @param  string $path Path of the file where it resides. (required)
     * @param  string $name Name of the file to be renamed. (required)
     * @param  string $newname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function renamefileRequest($path, $name, $newname)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling renamefile'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling renamefile'
            );
        }
        // verify the required parameter 'newname' is set
        if ($newname === null || (is_array($newname) && count($newname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $newname when calling renamefile'
            );
        }

        $resourcePath = '/core/renamefile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($newname !== null) {
            $queryParams['newname'] = ObjectSerializer::toQueryValue($newname);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation renameormove
     *
     * File_Related_API - renameormove is used to move files within the FC system
     *
     * @param  string $fromname Name of the file with the path where the file resides. (required)
     * @param  string $toname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Commands
     */
    public function renameormove($fromname, $toname)
    {
        list($response) = $this->renameormoveWithHttpInfo($fromname, $toname);
        return $response;
    }

    /**
     * Operation renameormoveWithHttpInfo
     *
     * File_Related_API - renameormove is used to move files within the FC system
     *
     * @param  string $fromname Name of the file with the path where the file resides. (required)
     * @param  string $toname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Commands, HTTP status code, HTTP response headers (array of strings)
     */
    public function renameormoveWithHttpInfo($fromname, $toname)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->renameormoveRequest($fromname, $toname);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Commands',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation renameormoveAsync
     *
     * File_Related_API - renameormove is used to move files within the FC system
     *
     * @param  string $fromname Name of the file with the path where the file resides. (required)
     * @param  string $toname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renameormoveAsync($fromname, $toname)
    {
        return $this->renameormoveAsyncWithHttpInfo($fromname, $toname)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation renameormoveAsyncWithHttpInfo
     *
     * File_Related_API - renameormove is used to move files within the FC system
     *
     * @param  string $fromname Name of the file with the path where the file resides. (required)
     * @param  string $toname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renameormoveAsyncWithHttpInfo($fromname, $toname)
    {
        $returnType = '\Swagger\Client\Model\Commands';
        $request = $this->renameormoveRequest($fromname, $toname);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'renameormove'
     *
     * @param  string $fromname Name of the file with the path where the file resides. (required)
     * @param  string $toname Name of the file with the path where the file has to be moved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function renameormoveRequest($fromname, $toname)
    {
        // verify the required parameter 'fromname' is set
        if ($fromname === null || (is_array($fromname) && count($fromname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fromname when calling renameormove'
            );
        }
        // verify the required parameter 'toname' is set
        if ($toname === null || (is_array($toname) && count($toname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $toname when calling renameormove'
            );
        }

        $resourcePath = '/core/renameormove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fromname !== null) {
            $queryParams['fromname'] = ObjectSerializer::toQueryValue($fromname);
        }
        // query params
        if ($toname !== null) {
            $queryParams['toname'] = ObjectSerializer::toQueryValue($toname);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchtermsearch
     *
     * File_Related_API - searchtermsearch api is used to specify the search term
     *
     * @param  string $searchterm Specify the search term (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Searchterms
     */
    public function searchtermsearch($searchterm)
    {
        list($response) = $this->searchtermsearchWithHttpInfo($searchterm);
        return $response;
    }

    /**
     * Operation searchtermsearchWithHttpInfo
     *
     * File_Related_API - searchtermsearch api is used to specify the search term
     *
     * @param  string $searchterm Specify the search term (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Searchterms, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchtermsearchWithHttpInfo($searchterm)
    {
        $returnType = '\Swagger\Client\Model\Searchterms';
        $request = $this->searchtermsearchRequest($searchterm);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Searchterms',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchtermsearchAsync
     *
     * File_Related_API - searchtermsearch api is used to specify the search term
     *
     * @param  string $searchterm Specify the search term (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchtermsearchAsync($searchterm)
    {
        return $this->searchtermsearchAsyncWithHttpInfo($searchterm)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchtermsearchAsyncWithHttpInfo
     *
     * File_Related_API - searchtermsearch api is used to specify the search term
     *
     * @param  string $searchterm Specify the search term (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchtermsearchAsyncWithHttpInfo($searchterm)
    {
        $returnType = '\Swagger\Client\Model\Searchterms';
        $request = $this->searchtermsearchRequest($searchterm);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchtermsearch'
     *
     * @param  string $searchterm Specify the search term (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchtermsearchRequest($searchterm)
    {
        // verify the required parameter 'searchterm' is set
        if ($searchterm === null || (is_array($searchterm) && count($searchterm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchterm when calling searchtermsearch'
            );
        }

        $resourcePath = '/core/searchtermsearch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($searchterm !== null) {
            $queryParams['searchterm'] = ObjectSerializer::toQueryValue($searchterm);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation upload
     *
     * File_Related_API - uploadfile is used to upload files to the system
     *
     * @param  string $appname Agent use to upload files to system (required)
     * @param  string $path Specify the path where you want to upload the file (required)
     * @param  float $offset Offset set to 0 (required)
     * @param  float $complete Complete set to 1 (required)
     * @param  string $filename File name to be uploaded inside the folder (required)
     * @param  \SplFileObject $file file (optional)
     * @param  \DateTime $date (Optional)Specify UTC date format (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function upload($appname, $path, $offset, $complete, $filename, $file = null, $date = null)
    {
        list($response) = $this->uploadWithHttpInfo($appname, $path, $offset, $complete, $filename, $file, $date);
        return $response;
    }

    /**
     * Operation uploadWithHttpInfo
     *
     * File_Related_API - uploadfile is used to upload files to the system
     *
     * @param  string $appname Agent use to upload files to system (required)
     * @param  string $path Specify the path where you want to upload the file (required)
     * @param  float $offset Offset set to 0 (required)
     * @param  float $complete Complete set to 1 (required)
     * @param  string $filename File name to be uploaded inside the folder (required)
     * @param  \SplFileObject $file (optional)
     * @param  \DateTime $date (Optional)Specify UTC date format (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadWithHttpInfo($appname, $path, $offset, $complete, $filename, $file = null, $date = null)
    {
        $returnType = 'string';
        $request = $this->uploadRequest($appname, $path, $offset, $complete, $filename, $file, $date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadAsync
     *
     * File_Related_API - uploadfile is used to upload files to the system
     *
     * @param  string $appname Agent use to upload files to system (required)
     * @param  string $path Specify the path where you want to upload the file (required)
     * @param  float $offset Offset set to 0 (required)
     * @param  float $complete Complete set to 1 (required)
     * @param  string $filename File name to be uploaded inside the folder (required)
     * @param  \SplFileObject $file (optional)
     * @param  \DateTime $date (Optional)Specify UTC date format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAsync($appname, $path, $offset, $complete, $filename, $file = null, $date = null)
    {
        return $this->uploadAsyncWithHttpInfo($appname, $path, $offset, $complete, $filename, $file, $date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadAsyncWithHttpInfo
     *
     * File_Related_API - uploadfile is used to upload files to the system
     *
     * @param  string $appname Agent use to upload files to system (required)
     * @param  string $path Specify the path where you want to upload the file (required)
     * @param  float $offset Offset set to 0 (required)
     * @param  float $complete Complete set to 1 (required)
     * @param  string $filename File name to be uploaded inside the folder (required)
     * @param  \SplFileObject $file (optional)
     * @param  \DateTime $date (Optional)Specify UTC date format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAsyncWithHttpInfo($appname, $path, $offset, $complete, $filename, $file = null, $date = null)
    {
        $returnType = 'string';
        $request = $this->uploadRequest($appname, $path, $offset, $complete, $filename, $file, $date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'upload'
     *
     * @param  string $appname Agent use to upload files to system (required)
     * @param  string $path Specify the path where you want to upload the file (required)
     * @param  float $offset Offset set to 0 (required)
     * @param  float $complete Complete set to 1 (required)
     * @param  string $filename File name to be uploaded inside the folder (required)
     * @param  \SplFileObject $file (optional)
     * @param  \DateTime $date (Optional)Specify UTC date format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadRequest($appname, $path, $offset, $complete, $filename, $file = null, $date = null)
    {
        // verify the required parameter 'appname' is set
        if ($appname === null || (is_array($appname) && count($appname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $appname when calling upload'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling upload'
            );
        }
        // verify the required parameter 'offset' is set
        if ($offset === null || (is_array($offset) && count($offset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling upload'
            );
        }
        // verify the required parameter 'complete' is set
        if ($complete === null || (is_array($complete) && count($complete) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $complete when calling upload'
            );
        }
        // verify the required parameter 'filename' is set
        if ($filename === null || (is_array($filename) && count($filename) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filename when calling upload'
            );
        }

        $resourcePath = '/core/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // form params
        if ($appname !== null) {
            $formParams['appname'] = ObjectSerializer::toFormValue($appname);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // form params
        if ($offset !== null) {
            $formParams['offset'] = ObjectSerializer::toFormValue($offset);
        }
        // form params
        if ($complete !== null) {
            $formParams['complete'] = ObjectSerializer::toFormValue($complete);
        }
        // form params
        if ($filename !== null) {
            $formParams['filename'] = ObjectSerializer::toFormValue($filename);
        }
        // form params
        if ($date !== null) {
            $formParams['date'] = ObjectSerializer::toFormValue($date);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
